package pass1

import (
	"bytes"
	"fmt"
	"net/netip"
	"path"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"golang.org/x/exp/maps"

	"github.com/hknutzen/Netspoc/go/pkg/ast"
	"github.com/hknutzen/Netspoc/go/pkg/filetree"
	"github.com/hknutzen/Netspoc/go/pkg/jcode"
	"github.com/hknutzen/Netspoc/go/pkg/parser"

	"go4.org/netipx"
)

func (c *spoc) readNetspoc(path string) {
	toplevel := c.parseFiles(path)
	c.setupTopology(toplevel)
}

func (c *spoc) showReadStatistics() {
	symTable := c.symTable
	r := len(symTable.router) + len(symTable.router6)
	n := len(symTable.network)
	h := len(symTable.host)
	s := len(symTable.service)
	c.info("Read: %d routers, %d networks, %d hosts, %d services", r, n, h, s)
}

func (c *spoc) parseFiles(dir string) []ast.Toplevel {
	var result []ast.Toplevel
	err := filetree.Walk(dir, c.conf.IPV6, func(input *filetree.Context) error {
		source := []byte(input.Data)
		aF, err := parser.ParseFile(source, input.Path, input.IPV6, 0)
		if err != nil {
			return err
		}
		if len(aF.Nodes) == 0 && input.Path != path.Join(dir, "POLICY") {
			if !bytes.HasPrefix(source, []byte("# Generated by")) {
				c.warn("Ignoring file '%s' without any content", input.Path)
			}
		}
		result = append(result, aF.Nodes...)
		return nil
	})
	if err != nil {
		c.abort("%v", err)
	}
	return result
}

func (c *spoc) setupTopology(toplevel []ast.Toplevel) {
	c.checkDuplicate(toplevel)
	c.symTable = createSymbolTable()
	c.initStdProtocols()
	c.setupObjects(toplevel)
	c.setAscendingServices()
	c.splitSemiManagedRouters()
	c.stopOnErr()
	c.linkTunnels()
	c.linkVirtualInterfaces()
	c.collectRoutersAndNetworks()
}

type symbolTable struct {
	// Leaf nodes, referencing nothing.
	isakmp map[string]*isakmp
	owner  map[string]*owner
	// Named protocols
	protocol map[string]*proto
	// Unnamed protocols like "tcp 80"
	unnamedProto map[string]*proto
	// References protocolgroup, protocol
	protocolgroup map[string]*protoGroup
	// References network, owner
	network   map[string]*network
	aggregate map[string]*network
	// References owner
	host map[string]*host
	// References host, owner, router, protocolgroup, protocol
	router  map[string]*router
	router6 map[string]*router
	// References network, owner, crypto, routerIntf(via crypto)
	routerIntf map[string]*routerIntf
	// References interface, group+, owner
	area map[string]*area
	// References group+, protocolgroup+, owner, service
	service map[string]*service
	// References host, network, interface, area, aggregate, group
	group map[string]*objGroup
	// References interface, group+
	pathrestriction map[string]*ast.TopList
	// References isakmp
	ipsec map[string]*ipsec
	// References ipsec
	crypto map[string]*crypto
	// Log tags of routers
	knownLog map[string]bool
}

func createSymbolTable() *symbolTable {
	s := new(symbolTable)
	s.network = make(map[string]*network)
	s.host = make(map[string]*host)
	s.router = make(map[string]*router)
	s.router6 = make(map[string]*router)
	s.routerIntf = make(map[string]*routerIntf)
	s.area = make(map[string]*area)
	s.service = make(map[string]*service)
	s.protocol = make(map[string]*proto)
	s.unnamedProto = make(map[string]*proto)
	s.protocolgroup = make(map[string]*protoGroup)
	s.group = make(map[string]*objGroup)
	s.pathrestriction = make(map[string]*ast.TopList)
	s.aggregate = make(map[string]*network)
	s.owner = make(map[string]*owner)
	s.crypto = make(map[string]*crypto)
	s.ipsec = make(map[string]*ipsec)
	s.isakmp = make(map[string]*isakmp)
	s.knownLog = make(map[string]bool)

	return s
}

func (c *spoc) setupObjects(l []ast.Toplevel) {
	s := c.symTable
	var ipsec []*ast.TopStruct
	var crypto []*ast.TopStruct
	var networks []*ast.Network
	var aggregates []*ast.TopStruct
	var routers []*ast.Router
	var areas []*ast.Area
	var pathrestrictions []*ast.TopList
	var services []*ast.Service
	for _, a := range l {
		typ, name := splitTypedName(a.GetName())
		switch a.(type) {
		case *ast.Network, *ast.Router:
		default:
			if !isSimpleName(name) {
				c.err("Invalid identifier in definition of '%s:%s'", typ, name)
			}
		}
		switch x := a.(type) {
		case *ast.Protocol:
			c.setupProtocol(x)
		case *ast.Protocolgroup:
			l := make(stringList, 0, len(x.ValueList))
			for _, v := range x.ValueList {
				l.push(v.Value)
			}
			s.protocolgroup[name] = &protoGroup{name: a.GetName(), list: l}
		case *ast.Network:
			n := new(network)
			// Set .name and .ipV6 early so that checkV4V6CrossRef works.
			n.name = x.Name
			n.ipV6 = x.IPV6
			s.network[name] = n
			networks = append(networks, x)
		case *ast.Router:
			r := new(router)
			r.name = x.Name
			r.ipV6 = x.IPV6
			if r.ipV6 {
				s.router6[name] = r
			} else {
				s.router[name] = r
			}
			routers = append(routers, x)
		case *ast.Area:
			areas = append(areas, x)
		case *ast.Service:
			s.service[name] = new(service)
			services = append(services, x)
		case *ast.TopStruct:
			switch typ {
			case "owner":
				c.setupOwner(x)
			case "isakmp":
				c.setupIsakmp(x)
			case "ipsec":
				ipsec = append(ipsec, x)
			case "crypto":
				crypto = append(crypto, x)
			case "any":
				aggregates = append(aggregates, x)
			}
		case *ast.TopList:
			switch typ {
			case "group":
				g := &objGroup{name: x.Name, elements: x.Elements}
				g.ipV6 = x.IPV6
				s.group[name] = g
			case "pathrestriction":
				pathrestrictions = append(pathrestrictions, x)
			}
		}
	}
	for _, a := range ipsec {
		c.setupIpsec(a)
	}
	for _, a := range crypto {
		c.setupCrypto(a)
	}
	for _, a := range networks {
		c.setupNetwork(a)
	}
	for _, a := range aggregates {
		c.setupAggregate(a)
	}
	for _, a := range routers {
		c.setupRouter(a)
	}
	for _, a := range areas {
		c.setupArea(a)
	}
	for _, a := range pathrestrictions {
		c.setupPathrestriction(a)
	}
	for _, a := range services {
		c.setupService(a)
	}
}

func (c *spoc) setAscendingServices() {
	s := c.symTable
	names := maps.Keys(s.service)
	sort.Strings(names)
	for _, name := range names {
		c.ascendingServices = append(c.ascendingServices, s.service[name])
	}
}

func (c *spoc) setupProtocol(a *ast.Protocol) {
	name := a.Name
	v := a.Value
	l := strings.Split(v, ", ")
	def := l[0]
	mod := l[1:]
	pSimp, pSrc := c.getSimpleProtocolAndSrcPort(def, a.IPV6, name)
	p := *pSimp
	p.name = name
	// Link named protocol with corresponding unnamed protocol.
	p.main = pSimp
	pName := name[len("protocol:"):]
	c.addProtocolModifiers(mod, &p, pSrc)
	c.symTable.protocol[pName] = &p
}

func (c *spoc) getSimpleProtocol(def string, v6 bool, ctx string) *proto {
	p, pSrc := c.getSimpleProtocolAndSrcPort(def, v6, ctx)
	if pSrc != nil {
		c.err("Must not use source port in %s.\n"+
			" Source port is only valid in named protocol", ctx)
	}
	return p
}

// Return protocol and optional protocol representing source port.
func (c *spoc) getSimpleProtocolAndSrcPort(
	def string, v6 bool, ctx string) (*proto, *proto) {

	var srcP *proto

	p := new(proto)
	p.name = def
	l := strings.Split(def, " ")
	proto := l[0]
	nums := l[1:]
	p.proto = proto
	switch proto {
	case "ip":
		if len(nums) != 0 {
			c.err("Unexpected details after %s", ctx)
		}
	case "tcp", "udp":
		src, dst := c.getSrcDstRange(nums, ctx)
		p.ports = dst
		if src[0] != 0 {
			cp := *p
			srcP = &cp
			srcP.ports = src
			srcP = c.cacheUnnamedProtocol(srcP)
		}
	case "icmp", "icmpv6":
		c.addICMPTypeCode(nums, p, v6, ctx)
	case "proto":
		c.addProtoNr(nums, p, ctx)
	default:
		c.err("Unknown protocol in %s", ctx)
		p.proto = "ip"
	}
	p = c.cacheUnnamedProtocol(p)
	return p, srcP
}

func (c *spoc) getSrcDstRange(nums []string, ctx string) ([2]int, [2]int) {
	var src, dst [2]int
	switch len(nums) {
	case 0:
		dst = [2]int{1, 65535}
	case 1:
		dst = c.getRange1(nums[0], ctx)
	case 3:
		if nums[1] == "-" {
			dst = c.getRange(nums[0], nums[2], ctx)
		} else if nums[1] == ":" {
			src = c.getRange1(nums[0], ctx)
			dst = c.getRange1(nums[2], ctx)
		} else {
			c.err("Invalid port range in %s", ctx)
		}
	case 5:
		if nums[1] == ":" && nums[3] == "-" {
			src = c.getRange1(nums[0], ctx)
			dst = c.getRange(nums[2], nums[4], ctx)
		} else if nums[1] == "-" && nums[3] == ":" {
			src = c.getRange(nums[0], nums[2], ctx)
			dst = c.getRange1(nums[4], ctx)
		} else {
			c.err("Invalid port range in %s", ctx)
		}
	case 7:
		if nums[1] == "-" && nums[3] == ":" && nums[5] == "-" {
			src = c.getRange(nums[0], nums[2], ctx)
			dst = c.getRange(nums[4], nums[6], ctx)
		} else {
			c.err("Invalid port range in %s", ctx)
		}
	default:
		c.err("Invalid port range in %s", ctx)
	}
	if dst[0] == 0 {
		dst = [2]int{1, 65535}
	}
	return src, dst
}

func (c *spoc) getRange(s1, s2 string, ctx string) [2]int {
	n1 := c.getPort(s1, ctx)
	n2 := c.getPort(s2, ctx)
	if n1 > n2 {
		c.err("Invalid port range in %s", ctx)
	}
	return [2]int{n1, n2}
}

func (c *spoc) getRange1(s1 string, ctx string) [2]int {
	n1 := c.getPort(s1, ctx)
	return [2]int{n1, n1}
}

func (c *spoc) getPort(s, ctx string) int {
	num, err := strconv.Atoi(s)
	if err != nil {
		c.err("Expected number in %s: %s", ctx, s)
		return -1
	}
	if num <= 0 {
		c.err("Expected port number > 0 in %s", ctx)
		return -1
	} else if num >= 65536 {
		c.err("Expected port number < 65536 in %s", ctx)
	}
	return num
}

func (c *spoc) addICMPTypeCode(nums []string, p *proto, v6 bool, ctx string) {
	p.icmpType = -1
	p.icmpCode = -1
	switch len(nums) {
	case 0:
		return
	case 3:
		if nums[1] != "/" {
			c.err("Expected [TYPE [ / CODE]] in %s", ctx)
			break
		}
		p.icmpCode = c.getNum256(nums[2], ctx)
		fallthrough
	case 1:
		typ := c.getNum256(nums[0], ctx)
		p.icmpType = typ
		if v6 {
			switch typ {
			case 1, 2, 3, 4, 129:
				p.statelessICMP = true
			}
		} else {
			switch typ {
			case 0, 3, 11:
				p.statelessICMP = true
			}
		}
	default:
		c.err("Expected [TYPE [ / CODE]] in %s", ctx)
	}
}

func (c *spoc) addProtoNr(nums []string, p *proto, ctx string) {
	if len(nums) != 1 {
		c.err("Expected single protocol number in %s", ctx)
		return
	}
	s := nums[0]
	switch c.getNum256(s, ctx) {
	case 0:
		c.err("Invalid protocol number '0' in %s", ctx)
	case 4:
		c.err("Must not use 'proto 4', use 'tcp' instead in %s", ctx)
		return
	case 17:
		c.err("Must not use 'proto 17', use 'udp' instead in %s", ctx)
		return
	}
	p.proto = s
}

func (c *spoc) getNum256(s, ctx string) int {
	num, err := strconv.Atoi(s)
	if err != nil {
		c.err("Expected number in %s: %s", ctx, s)
		return -1
	}
	if num >= 256 {
		c.err("Expected number < 256 in %s", ctx)
	}
	return num
}

func (c *spoc) addProtocolModifiers(l []string, p *proto, srcP *proto) {
	if len(l) == 0 && srcP == nil {
		return
	}
	m := new(modifiers)
	for _, s := range l {
		switch s {
		case "reversed":
			m.reversed = true
		case "stateless":
			m.stateless = true
		case "oneway":
			m.oneway = true
		case "src_net":
			m.srcNet = true
		case "dst_net":
			m.dstNet = true
		case "overlaps":
			m.overlaps = true
		case "no_check_supernet_rules":
			m.noCheckSupernetRules = true
		default:
			c.err("Unknown modifier '%s' in %s", s, p.name)
		}
	}
	if srcP != nil {
		m.srcRange = srcP
	}
	p.modifiers = m
}

func (c *spoc) setupOwner(v *ast.TopStruct) {
	name := v.Name
	o := new(owner)
	o.name = name
	oName := name[len("owner:"):]
	c.symTable.owner[oName] = o
	for _, a := range v.Attributes {
		switch a.Name {
		case "admins":
			o.admins = c.getEmailList(a, name)
		case "watchers":
			o.watchers = c.getEmailList(a, name)
		case "show_all":
			o.showAll = c.getFlag(a, name)
			o.showHiddenOwners = true
		case "only_watch":
			o.onlyWatch = c.getFlag(a, name)
		case "hide_from_outer_owners":
			o.hideFromOuterOwners = c.getFlag(a, name)
		case "show_hidden_owners":
			o.showHiddenOwners = c.getFlag(a, name)
		default:
			if c.addAttr(a, &o.attr, name) {
				if o.attr[unknownOwnerAttr] != unsetVal {
					o.attr[unknownOwnerAttr] = unsetVal
					c.warn("Ignoring attribute 'unknown_owner' in %s", name)
				}
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	c.removeDupl(append(o.admins, o.watchers...), "admins/watchers of "+name)
}

type attrDescr struct {
	values   []string
	mapEmpty string
}

var isakmpAttr = map[string]attrDescr{
	"nat_traversal": attrDescr{
		values:   []string{"on", "additional", "off"},
		mapEmpty: "off",
	},
	"authentication": {
		values: []string{"preshare", "rsasig"},
	},
	"encryption": {
		values: []string{
			"aes", "aes192", "aes256", "des", "3des",
			"aes-gcm", "aes-gcm-192", "aes-gcm-256",
		},
	},
	"hash": {
		values: []string{"md5", "sha", "sha256", "sha384", "sha512"},
	},
	"ike_version": {
		values: []string{"1", "2"},
	},
	"group": {
		values: []string{"1", "2", "5", "14", "15", "16", "19", "20", "21", "24"},
	},
	"trust_point": {
		mapEmpty: "none",
	},
}

func (c *spoc) setupIsakmp(v *ast.TopStruct) {
	name := v.Name
	is := new(isakmp)
	is.name = name
	isName := name[len("isakmp:"):]
	c.symTable.isakmp[isName] = is
	hasLifetime := false
	ikeVersion := ""
	for _, a := range v.Attributes {
		switch a.Name {
		case "nat_traversal":
			is.natTraversal = c.getAttr(a, isakmpAttr, name)
		case "authentication":
			is.authentication = c.getAttr(a, isakmpAttr, name)
		case "encryption":
			is.encryption = c.getAttr(a, isakmpAttr, name)
		case "hash":
			is.hash = c.getAttr(a, isakmpAttr, name)
		case "ike_version":
			ikeVersion = c.getAttr(a, isakmpAttr, name)
		case "lifetime":
			is.lifetime = c.getTimeVal(a, name)
			hasLifetime = true
		case "group":
			is.group = c.getAttr(a, isakmpAttr, name)
		case "trust_point":
			is.trustPoint = c.getAttr(a, isakmpAttr, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	if ikeVersion == "" {
		is.ikeVersion = 1
	} else {
		is.ikeVersion, _ = strconv.Atoi(ikeVersion)
	}
	if is.authentication == "" {
		c.err("Missing 'authentication' for %s", name)
	}
	if is.encryption == "" {
		c.err("Missing 'encryption' for %s", name)
	}
	if is.hash == "" {
		c.err("Missing 'hash' for %s", name)
	}
	if is.group == "" {
		c.err("Missing 'group' for %s", name)
	}
	if !hasLifetime {
		c.err("Missing 'lifetime' for %s", name)
	}
	c.checkDuplAttr(v.Attributes, name)
}

func (c *spoc) getAttr(a *ast.Attribute, descr map[string]attrDescr, ctx string) string {
	v := c.getSingleValue(a, ctx)
	d := descr[a.Name]
	if l := d.values; l != nil {
		valid := false
		for _, v2 := range l {
			if v == v2 {
				valid = true
				break
			}
		}
		if !valid {
			c.err("Invalid value in '%s' of %s: %s", a.Name, ctx, v)
		}
	}
	if v2 := d.mapEmpty; v2 != "" && v == v2 {
		v = ""
	}
	return v
}

var ipsecAttr = map[string]attrDescr{
	"esp_encryption": {
		values: []string{
			"none", "3des", "aes", "aes192", "aes256", "des",
			"aes-gcm", "aes-gcm-192", "aes-gcm-256",
			"aes-gmac", "aes-gmac-192", "aes-gmac-256",
		},
	},
	"esp_authentication": {
		values: []string{"none", "md5", "sha", "sha256", "sha384", "sha512"},
	},
	"ah": {
		values: []string{"none", "md5", "sha", "sha256", "sha384", "sha512"},
	},
	"pfs_group": {
		values: []string{"1", "2", "5", "14", "15", "16", "19", "20", "21", "24"},
	},
}

func (c *spoc) setupIpsec(v *ast.TopStruct) {
	name := v.Name
	is := new(ipsec)
	is.name = name
	isName := name[len("ipsec:"):]
	c.symTable.ipsec[isName] = is
	for _, a := range v.Attributes {
		switch a.Name {
		case "key_exchange":
			is.isakmp = c.getIsakmpRef(a, name)
		case "esp_encryption":
			is.espEncryption = c.getAttr(a, ipsecAttr, name)
		case "esp_authentication":
			is.espAuthentication = c.getAttr(a, ipsecAttr, name)
		case "ah":
			is.ah = c.getAttr(a, ipsecAttr, name)
		case "pfs_group":
			is.pfsGroup = c.getAttr(a, ipsecAttr, name)
		case "lifetime":
			is.lifetime = c.getTimeKilobytesPair(a, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	if is.lifetime == nil {
		c.err("Missing 'lifetime' for %s", name)
	}
	if is.isakmp == nil {
		c.err("Missing 'key_exchange' for %s", name)
	}
}

func (c *spoc) setupCrypto(v *ast.TopStruct) {
	name := v.Name
	cr := new(crypto)
	cr.name = name
	crName := name[len("crypto:"):]
	c.symTable.crypto[crName] = cr
	for _, a := range v.Attributes {
		switch a.Name {
		case "bind_nat":
			cr.bindNat = c.getBindNat(a, name)
		case "detailed_crypto_acl":
			cr.detailedCryptoAcl = c.getFlag(a, name)
		case "type":
			cr.ipsec = c.getIpsecRef(a, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	if cr.ipsec == nil {
		c.err("Missing 'type' for %s", name)
	}
}

func (c *spoc) setupNetwork(v *ast.Network) {
	name := v.Name
	netName := name[len("network:"):]
	n := c.symTable.network[netName]
	n.name = name
	n.ipV6 = v.IPV6
	i := strings.Index(netName, "/")
	if i != -1 {
		n.ipType = bridgedIP
	}
	if i != -1 && !isSimpleName(netName[:i]) || !isSimpleName(netName[i+1:]) {
		c.err("Invalid identifier in definition of '%s'", name)
	}
	var ldapAppend string
	ipGiven := false
	for _, a := range v.Attributes {
		switch a.Name {
		case "ip":
			n.ipp = c.getIpPrefix(a, v.IPV6, name)
			ipGiven = true
		case "unnumbered":
			if c.getFlag(a, name) {
				if n.ipType == bridgedIP {
					c.err("Unnumbered %s must not be bridged", name)
				}
				n.ipType = unnumberedIP
			}
		case "has_subnets":
			n.hasSubnets = c.getFlag(a, name)
		case "crosslink":
			n.crosslink = c.getFlag(a, name)
		case "subnet_of":
			n.subnetOf = c.tryNetworkRef(a, n.ipV6, name)
		case "owner":
			n.owner = c.getRealOwnerRef(a, name)
		case "cert_id":
			n.certId = c.getSingleValue(a, name)
		case "ldap_append":
			ldapAppend = c.getSingleValue(a, name)
		case "radius_attributes":
			n.radiusAttributes = c.getRadiusAttributes(a, name)
		case "partition":
			n.partition = c.getIdentifier(a, name)
		default:
			if c.addAttr(a, &n.attr, name) {
			} else if nat := c.addNetNat(a, n.nat, v.IPV6, name); nat != nil {
				n.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	for _, a := range v.Hosts {
		h := c.setupHost(a, n)
		if h.ldapId != "" {
			h.ldapId += ldapAppend
		}
	}

	// Unnumbered network must not have any other attributes.
	if n.ipType == unnumberedIP {
		for _, a := range v.Attributes {
			switch a.Name {
			case "crosslink", "unnumbered":
			default:
				if strings.HasPrefix(a.Name, "nat:") {
					c.err("Unnumbered %s must not have NAT definition", name)
				} else {
					c.err("Unnumbered %s must not have attribute '%s'",
						name, a.Name)
				}
			}
		}
		if len(n.hosts) != 0 {
			c.err("Unnumbered %s must not have host definition", name)
		}
	} else if n.ipType == bridgedIP {
		for _, h := range n.hosts {
			if h.ipRange.From().IsValid() {
				c.err("Bridged %s must not have %s with range (not implemented)",
					name, h.name)
			}
		}
		for _, nat := range n.nat {
			if !nat.identity {
				c.err("Only identity NAT allowed for bridged %s", n)
				break
			}
		}
	} else if !ipGiven {
		c.err("Missing IP address for %s", name)
	} else if ipp := n.ipp; ipp.IsValid() {
		for _, h := range n.hosts {

			// Check compatibility of host IP and network IP/mask.
			if h.ip.IsValid() {
				if !ipp.Contains(h.ip) {
					c.err("IP of %s doesn't match IP/mask of %s", h, name)
				}
			}
			if h.ipRange.IsValid() {
				// Check range.
				if !(ipp.Contains(h.ipRange.From()) &&
					ipp.Contains(h.ipRange.To())) {

					c.err("IP range of %s doesn't match IP/mask of %s", h, name)
				}
			}

			// Compatibility of host and network NAT will be checked later,
			// after inherited NAT definitions have been processed.
		}
		if n.hosts != nil && n.crosslink {
			c.err("Crosslink %s must not have host definitions", name)
		}

		// Check NAT definitions.
		for tag, nat := range n.nat {
			if !nat.dynamic {
				if nat.ipp.Bits() != ipp.Bits() {
					c.err("Mask for non dynamic nat:%s must be equal to mask of %s",
						tag, name)
				}
			}
		}

		// Check and mark networks with ID-hosts.
		ldapCount := 0
		idHostsCount := 0
		for _, h := range n.hosts {
			if h.ldapId != "" {
				ldapCount++
				h.id = h.ldapId
			} else if h.id != "" {
				idHostsCount++
			}
		}
		if ldapCount > 0 {

			// If one host has ldap_id, all hosts must have ldap_id.
			if len(n.hosts) != ldapCount {
				c.err("All hosts must have attribute 'ldap_id' in %s", name)
			}
			if n.certId == "" {
				c.err("Missing attribute 'cert_id' at %s having hosts"+
					" with attribute 'ldap_id'", name)
			} else if !isDomain(n.certId) {
				c.err("Domain name expected in attribute 'cert_id' of %s", name)
			}

			// Mark network.
			n.hasIdHosts = true
		} else {
			if ldapAppend != "" {
				c.warn("Ignoring 'ldap_append' at %s", name)
			}
			if n.certId != "" {
				n.certId = ""
				c.warn("Ignoring 'cert_id' at %s", name)
			}
			if idHostsCount > 0 {

				// If one host has ID, all hosts must have ID.
				if len(n.hosts) != idHostsCount {
					c.err("All hosts must have ID in %s", name)
				}

				// Mark network.
				n.hasIdHosts = true
			}
		}

		if !n.hasIdHosts && n.radiusAttributes != nil {
			c.warn("Ignoring 'radius_attributes' at %s", name)
		}
	}
}

func (c *spoc) setupHost(v *ast.Attribute, n *network) *host {
	name := v.Name
	v6 := n.ipV6
	h := new(host)
	h.ipV6 = v6
	hName := name[len("host:"):]
	if strings.HasPrefix(hName, "id:") {
		id := hName[len("id:"):]
		if !isIdHostname(id) {
			c.err("Invalid name in definition of '%s'", name)
		}
		h.id = id
		nName := n.name[len("network:"):]
		hName += "." + nName
		name += "." + nName
	} else {
		if !isSimpleName(hName) {
			c.err("Invalid identifier in definition of '%s'", name)
		}
	}
	h.name = name
	c.symTable.host[hName] = h
	h.network = n
	n.hosts = append(n.hosts, h)

	l := c.getComplexValue(v, "")
	ipGiven := 0
	for _, a := range l {
		switch a.Name {
		case "ip":
			h.ip = c.getIp(a, v6, name)
			ipGiven++
		case "range":
			h.ipRange = c.getIpRange(a, v6, name)
			ipGiven++
		case "owner":
			h.owner = c.getRealOwnerRef(a, name)
		case "ldap_id":
			h.ldapId = c.getSingleValue(a, name)
		case "radius_attributes":
			h.radiusAttributes = c.getRadiusAttributes(a, name)
		default:
			if nat := c.addIPNat(a, h.nat, v6, name); nat != nil {
				h.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	if ipGiven != 1 {
		c.err("%s needs exactly one of attributes 'ip' and 'range'", name)
	}
	if h.id != "" {
		if h.ldapId != "" {
			c.warn("Ignoring attribute 'ldap_id' at %s", name)
			h.ldapId = ""
		}
	} else if h.ldapId != "" {
		if !h.ipRange.From().IsValid() {
			c.err("Attribute 'ldap_Id' must only be used together with"+
				" IP range at %s", name)
		}
	} else if h.radiusAttributes != nil {
		c.warn("Ignoring 'radius_attributes' at %s", name)
	}
	if h.nat != nil && h.ipRange.From().IsValid() {
		// Before changing this,
		// add consistency tests in convert_hosts.
		c.err("No NAT supported for %s with 'range'", name)
	}
	return h
}

func (c *spoc) setupAggregate(v *ast.TopStruct) {
	name := v.Name
	v6 := v.IPV6
	ag := new(network)
	ag.name = name
	ag.isAggregate = true
	ag.ipV6 = v6
	agName := name[len("any:"):]
	c.symTable.aggregate[agName] = ag
	hasLink := false
	for _, a := range v.Attributes {
		switch a.Name {
		case "ip":
			ag.ipp = c.getIpPrefix(a, v.IPV6, name)
		case "link":
			hasLink = true
			ag.link = c.getNetworkRef(a, v6, name)
		case "no_check_supernet_rules":
			ag.noCheckSupernetRules = c.getFlag(a, name)
		case "owner":
			ag.owner = c.getRealOwnerRef(a, name)
		default:
			if c.addAttr(a, &ag.attr, name) {
			} else if nat := c.addNetNat(a, ag.nat, v.IPV6, name); nat != nil {
				ag.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	if !hasLink {
		c.err("Attribute 'link' must be defined for %s", name)
	}
	if !ag.ipp.IsValid() {
		ag.ipp = c.getNetwork00(v6).ipp
	}
	if ag.ipp.Bits() != 0 {
		for _, a := range v.Attributes {
			switch a.Name {
			case "ip", "link", "owner",
				"overlaps", "identical_body", "multi_owner", "has_unenforceable":
				continue
			}
			if !strings.HasPrefix(a.Name, "nat:") {
				c.err("Must not use attribute '%s' if IP is set for %s",
					a.Name, name)
			}
		}
	}
}

func (c *spoc) setupArea(v *ast.Area) {
	name := v.Name
	v6 := v.IPV6
	ar := new(area)
	ar.name = name
	ar.ipV6 = v6
	arName := name[len("area:"):]
	c.symTable.area[arName] = ar
	for _, a := range v.Attributes {
		switch a.Name {
		case "anchor":
			ar.anchor = c.getNetworkRef(a, v.IPV6, name)
		case "router_attributes":
			ar.routerAttributes = c.getRouterAttributes(a, ar)
		case "owner":
			o := c.tryOwnerRef(a, name)
			if o != nil && o.onlyWatch {
				ar.watchingOwner = o
			} else {
				ar.owner = o
			}
		default:
			if c.addAttr(a, &ar.attr, name) {
			} else if nat := c.addNetNat(a, ar.nat, v.IPV6, name); nat != nil {
				ar.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(v.Attributes, name)
	expand := func(u *ast.NamedUnion, att string) intfList {
		if u == nil {
			return nil
		}
		ctx := "'" + att + "' of " + name
		l := c.expandGroup(u.Elements, ctx, v.IPV6, false)
		result := make(intfList, 0, len(l))
		for _, el := range l {
			intf, ok := el.(*routerIntf)
			if !ok {
				c.err("Unexpected '%s' in %s", el, ctx)
			} else if intf.router.managed == "" {
				c.err("Must not reference unmanaged %s in %s", intf, ctx)
			} else {
				// Reverse swapped main and virtual interface.
				if main := intf.mainIntf; main != nil {
					intf = main
				}
				result.push(intf)
			}
		}
		return result
	}
	ar.border = expand(v.Border, "border")
	ar.inclusiveBorder = expand(v.InclusiveBorder, "inclusive_border")
	if (len(ar.border) != 0 || len(ar.inclusiveBorder) != 0) &&
		ar.anchor != nil {
		c.err("Attribute 'anchor' must not be defined together with"+
			" 'border' or 'inclusive_border' for %s", name)
	}
	if len(ar.border) == 0 && len(ar.inclusiveBorder) == 0 && ar.anchor == nil {
		c.err("At least one of attributes 'border', 'inclusive_border'"+
			" or 'anchor' must be defined for %s", name)
	}
}

func (c *spoc) setupPathrestriction(v *ast.TopList) {
	name := v.Name
	l := c.expandGroup(v.Elements, name, v.IPV6, false)
	elements := make(intfList, 0, len(l))
	for _, obj := range l {
		intf, ok := obj.(*routerIntf)
		if !ok {
			c.err("%s must not reference %s", name, obj)
		} else if intf.mainIntf != nil {
			// Pathrestrictions must not be applied to secondary interfaces
			c.err("%s must not reference secondary %s", name, obj)
		} else {
			elements.push(intf)
		}
	}
	switch len(elements) {
	case 0:
		c.warn("Ignoring %s without elements", name)
	case 1:
		c.warn("Ignoring %s with only %s", name, elements[0])
		elements = nil
	}
	if len(elements) == 0 {
		return
	}
	c.addPathrestriction(name, elements)
}

func (c *spoc) setupRouter(v *ast.Router) {
	name := v.Name
	rName := name[len("router:"):]
	v6 := v.IPV6
	r := c.getRouter(rName, v6)
	c.allRouters = append(c.allRouters, r)
	i := strings.Index(rName, "@")
	if i != -1 {
		r.deviceName = rName[:i]
		r.vrf = rName[i+1:]
	} else {
		r.deviceName = rName
	}
	if i != -1 && !isSimpleName(rName[:i]) || !isSimpleName(rName[i+1:]) {
		c.err("Invalid identifier in definition of '%s'", name)
	}
	noProtectSelf := false
	var routingDefault *mcastProto
	for _, a := range v.Attributes {
		switch a.Name {
		case "managed":
			r.managed = c.getManaged(a, name)
		case "filter_only":
			r.filterOnly = c.getIpPrefixList(a, v6, name)
		case "merge_tunnelspecified":
			r.mergeTunnelSpecified = c.getIpPrefixList(a, v6, name)
		case "model":
			r.model = c.getModel(a, name)
		case "no_group_code":
			r.noGroupCode = c.getFlag(a, name)
		case "no_protect_self":
			noProtectSelf = c.getFlag(a, name)
		case "log_default":
			r.logDefault = c.getLogModifiers(a, name)
		case "log_deny":
			r.logDeny = c.getLogModifiers(a, name)
		case "routing":
			routingDefault = c.getRouting(a, name)
		case "owner":
			r.owner = c.getRealOwnerRef(a, name)
		case "radius_attributes":
			r.radiusAttributes = c.getRadiusAttributes(a, name)
		case "policy_distribution_point":
			r.policyDistributionPoint = c.tryHostRef(a, v6, name)
		case "general_permit":
			r.generalPermit = c.getGeneralPermit(a, v6, name)
		case "management_instance":
			r.managementInstance = c.getFlag(a, name)
		case "backup_of":
			r.backupOf = c.tryRouterRef(a, v6, name)
		default:
			if !c.addLog(a, r) {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(v.Attributes, name)

	// Find bridged interfaces of this device and check
	// existence of corresponding layer3 device.
	var l3Name string
	if r.managed != "" {

		// Search bridge interface having
		// 1. name "interface:network/part" and
		// 2. no IP address.
		var bName string
	BRIDGED:
		for _, a := range v.Interfaces {
			other, _, found := strings.Cut(a.Name, "/")
			if !found {
				continue
			}
			for _, a2 := range a.ComplexValue {
				switch a2.Name {
				case "ip", "unnumbered", "negotiated":
					break BRIDGED
				}
			}
			// Remember name of corresponding layer3 interface without "/part".
			// One router must not bridge parts of different networks.
			// This would complicate check for interface without IP address
			// as hop for static routing in checkIPAddr.
			if l3Name != "" {
				if l3Name != other {
					c.err("Must not bridge parts of different networks at %s:\n%s",
						name, stringList{bName, a.Name}.nameList())
				}
			} else {
				l3Name = other
				bName = a.Name
			}
		}
		if l3Name != "" {
			// Check existence of layer3 interface.
			seen := false
			for _, a := range v.Interfaces {
				if a.Name == l3Name {
					seen = true
					break
				}
			}
			if !seen {
				c.err("Must define %s at %s for corresponding bridge interfaces",
					l3Name, name)
			}
		}
	}

	// Create objects representing hardware interfaces.
	// All logical interfaces using the same hardware are linked
	// to the same hardware object.
	hwMap := make(map[string]*hardware)
	for _, a := range v.Interfaces {
		c.setupInterface(a, hwMap, l3Name, r)
	}

	if managed := r.managed; managed != "" {
		if r.model == nil {
			c.err("Missing 'model' for managed %s", name)

			// Prevent further errors.
			r.model = &model{name: "unknown"}
		}

		// Router is semiManaged if only routes are generated.
		if managed == "routing_only" {
			r.semiManaged = true
			r.routingOnly = true
			r.managed = ""
		}

		if r.vrf != "" && !r.model.canVRF {
			c.err("Must not use VRF at %s of model %s", name, r.model.class)
		}
		if r.vrf == "" && r.model.needVRF {
			c.err("Must use VRF ('@...' in name) at %s of model %s",
				name, r.model.class)
		}
		if r.model.filter == "NSX" {
			if len(hwMap) != 2 || hwMap["IN"] == nil || hwMap["OUT"] == nil {
				c.err("%s of model %s must have exactly 2 interfaces"+
					" with hardware IN and OUT", r, r.model.class)
			}
			if r.model.tier == "" {
				c.err("Must add extension 'T0' or 'T1' at %s of model %s",
					r, r.model.class)
			}
		}
		for _, hw := range hwMap {
			l := hw.interfaces
			if r.model.noSharedHardware && len(l) > 1 {
				c.err("Different interfaces must not share same hardware '%s'"+
					" at %s of model %s", hw.name, name, r.model.class)
			}

			// All logical interfaces of one hardware interface need to
			// use the same NAT binding, because NAT operates on
			// hardware, not on logic.
			intf := l[0]
			for _, other := range l[1:] {
				if !bindNatEq(intf.bindNat, other.bindNat) {
					c.err("%s and %s using identical 'hardware = %s'\n"+
						" must also use identical NAT binding", intf, other, hw.name)
				}
			}
		}

		for _, intf := range withSecondary(r.interfaces) {
			// Inherit attribute 'routing' to interfaces.
			if routingDefault != nil {
				if intf.routing == nil {
					if intf.ipType == bridgedIP {
						c.err("Attribute 'routing' not supported for bridge %s", name)
					} else if !intf.loopback {
						intf.routing = routingDefault
					}
				}
			}
			if rt := intf.routing; rt != nil && intf.ipType == unnumberedIP {
				switch rt.name {
				case "manual", "dynamic":
				default:
					c.err("Routing '%s' not supported for unnumbered %s",
						rt.name, intf)
				}
			}
		}
	} else {
		// Unmanaged device.
		if r.owner != nil {
			c.warn("Ignoring attribute 'owner' at unmanaged %s", name)
		}
	}

	// Check again after "managed=routing_only" has been removed.
	if managed := r.managed; managed != "" {
		if managed == "local" {
			if r.filterOnly == nil {
				c.err("Missing attribute 'filter_only' for %s", name)
			}
			if r.model.hasIoACL {
				c.err("Must not use 'managed = local' at %s of model %s",
					name, r.model.name)
			}
		} else if r.filterOnly != nil {
			c.warn(
				"Ignoring attribute 'filter_only' at %s;"+
					" only valid with 'managed = local'", name)
			r.filterOnly = nil
		}

		for name, modList := range r.log {
			c.symTable.knownLog[name] = true
			r.log[name] = c.transformLog("log:"+name, modList, r)
		}
		if modList := r.logDefault; modList != "" {
			r.logDefault = c.transformLog("log_default", modList, r)
		}
		if modList := r.logDeny; modList != "" {
			r.logDeny = c.transformLog("log_deny", modList, r)
		}

		if noProtectSelf && !r.model.needProtect {
			c.err("Must not use attribute 'no_protect_self' at %s of model %s",
				name, r.model.name)
		}
		if r.model.needProtect {
			r.needProtect = !noProtectSelf
		}

		// Detailed interface processing for managed routers.
		isCryptoHub := false
		hasBindNat := false
		for _, intf := range r.interfaces {
			if intf.hub != nil || intf.spoke != nil {
				if r.model.crypto == "" {
					c.err("Crypto not supported for %s of model %s",
						name, r.model.name)
				}
			}
			if intf.hub != nil {
				isCryptoHub = true
			}
			if intf.bindNat != nil {
				hasBindNat = true
			}
			// Link bridged interfaces with corresponding layer3 device.
			// Used in findAutoInterfaces.
			if intf.ipType == bridgedIP {
				layer3Name := intf.name[len("interface:"):]
				layer3Name, _, _ = strings.Cut(layer3Name, "/")
				intf.layer3Intf = c.symTable.routerIntf[layer3Name]
			}
		}

		c.checkNoInAcl(r)

		if r.managed == "local" {
			if hasBindNat {
				c.err("Attribute 'bind_nat' is not allowed"+
					" at interface of %s with 'managed = local'", name)
			}
		}
		if r.model.doAuth {
			if !isCryptoHub {
				c.warn("Attribute 'hub' needs to be defined"+
					" at some interface of %s of model %s", name, r.model.name)
			}
		} else {
			if r.radiusAttributes != nil {
				c.warn("Ignoring 'radius_attributes' at %s", name)
			}
			if r.mergeTunnelSpecified != nil {
				c.warn("Ignoring 'merge_tunnelspecified' at %s", name)
			}
		}
	}

	if r.managementInstance {
		if r.managed != "" || r.routingOnly {
			c.warn("Ignoring attribute 'management_instance' at managed %s",
				name)
		} else if r.model == nil {
			c.warn("Ignoring attribute 'management_instance' at %s"+
				" without model",
				name)
		} else if !r.model.needManagementInstance {
			c.warn("Ignoring attribute 'management_instance' at %s of model %s",
				name, r.model.name)
		} else if len(r.interfaces) != 1 {
			c.err("%s with attribute 'management_instance' needs"+
				" exactly one interface", name)
		} else if r.interfaces[0].ipType != hasIP {
			c.err("%s with attribute 'management_instance' needs"+
				" interface with IP address", name)
		} else {
			// This simplifies inheritance of policy_distribution_point
			// from area to management_instance.
			r.semiManaged = true
		}
		if r.vrf != "" {
			c.err("%s with attribute 'management_instance' must not use VRF", name)
		}
		if r2 := r.backupOf; r2 != nil {
			// r2.deviceName is set, if r2 already has been parsed.
			if r2.deviceName != "" && !r2.managementInstance {
				c.warn("Ignoring attribute 'backup_of' at %s,\n"+
					" because %s hasn't attribute 'management_instance'",
					name, r2.name)
			} else if r3 := r2.backupInstance; r3 != nil {
				c.warn("Ignoring attribute 'backup_of' at %s,\n"+
					" because %s is already 'backup_of' %s",
					name, r3.name, r2.name)
			} else {
				r2.backupInstance = r
			}
		}
	} else {
		if r.backupOf != nil {
			c.warn("Ignoring attribute 'backup_of' at %s"+
				" without attribute 'management_instance'",
				name)
		}
		// Attribute .backupInstance has been set before r was parsed.
		if r2 := r.backupInstance; r2 != nil {
			c.warn("Ignoring attribute 'backup_of' at %s,\n"+
				" because %s hasn't attribute 'management_instance'",
				r2.name, name)
		}
		if r.policyDistributionPoint != nil &&
			r.model != nil && r.model.needManagementInstance {

			c.warn("Ignoring attribute 'policy_distribution_point' at %s\n"+
				" Add this attribute at 'management_instance' instead",
				name)
		}
	}

	var otherSpoke *routerIntf
	for _, intf := range r.interfaces {

		if cr := intf.spoke; cr != nil {
			if otherSpoke != nil {
				c.err("Must not define crypto spoke at more than one interface:\n"+
					" - %s\n"+
					" - %s", otherSpoke, intf)
				continue
			}
			otherSpoke = intf
			// Create tunnel network.
			netName := "tunnel:" + rName
			tNet := new(network)
			tNet.name = "network:" + netName
			tNet.ipType = tunnelIP
			tNet.ipV6 = v6

			// Tunnel network will later be attached to crypto hub.
			cr.tunnels.push(tNet)

			// Create tunnel interface.
			iName := rName + "." + netName
			tIntf := new(routerIntf)
			tIntf.name = "interface:" + iName
			tIntf.ipType = tunnelIP
			tIntf.router = r
			tIntf.network = tNet
			tIntf.realIntf = intf
			tIntf.routing = intf.routing
			tIntf.bindNat = intf.bindNat
			tIntf.id = intf.id
			tIntf.ipV6 = v6
			if r.managed != "" {
				hw := intf.hardware
				tIntf.hardware = hw
				hw.interfaces.push(tIntf)
			}
			r.interfaces.push(tIntf)
			tNet.interfaces.push(tIntf)
		}

		if (intf.spoke != nil || intf.hub != nil) && !intf.noCheck {
			c.moveLockedIntf(intf)
		}
	}
}

func withSecondary(l intfList) intfList {
	result := l
	for _, intf := range l {
		result = append(result, intf.secondaryIntfs...)
	}
	return result
}

func (c *spoc) setupInterface(v *ast.Attribute,
	hwMap map[string]*hardware, l3Name string, r *router) {

	rName := r.name[len("router:"):]
	nName := v.Name[len("interface:"):]
	iName := rName + "." + nName
	name := "interface:" + iName
	v6 := r.ipV6
	intf := new(routerIntf)
	intf.name = name
	intf.ipV6 = v6
	var l []*ast.Attribute

	// Allow short form of interface definition.
	if !emptyAttr(v) {
		l = c.getComplexValue(v, r.name)
	}

	var secondaryList intfList
	var virtual *routerIntf
	var vip bool
	var hwName string
	var subnetOf *network
	var nat natTagMap
	ipGiven := false
	for _, a := range l {
		switch a.Name {
		case "ip":
			ipGiven = true
			if ipList := c.getIpList(a, v6, name); ipList != nil {
				intf.ip = ipList[0]

				// Build interface objects for secondary IP addresses.
				// These objects are named interface:router.name.2, ...
				counter := 2
				for _, ip := range ipList[1:] {
					suffix := "." + strconv.Itoa(counter)
					name := name + suffix
					intf := new(routerIntf)
					intf.name = name
					intf.ipV6 = v6
					intf.ip = ip
					secondaryList.push(intf)
					counter++
				}
			}
		case "hardware":
			hwName = c.getSingleValue(a, name)
		case "owner":
			intf.owner = c.getRealOwnerRef(a, name)
		case "unnumbered":
			c.getFlag(a, name)
			intf.ipType = unnumberedIP
		case "negotiated":
			c.getFlag(a, name)
			intf.ipType = negotiatedIP
		case "loopback":
			intf.loopback = c.getFlag(a, name)
		case "vip":
			vip = c.getFlag(a, name)
		case "no_in_acl":
			intf.noInAcl = c.getFlag(a, name)
		case "dhcp_server":
			intf.dhcpServer = c.getFlag(a, name)
		case "dhcp_client":
			intf.dhcpClient = c.getFlag(a, name)
		case "subnet_of":
			subnetOf = c.tryNetworkRef(a, v6, name)
		case "hub":
			intf.hub = c.getCryptoRefList(a, name)
		case "spoke":
			intf.spoke = c.getCryptoRef(a, name)
		case "id":
			intf.id = c.getSingleValue(a, name)
		case "virtual":
			virtual = c.getVirtual(a, v6, name)
		case "bind_nat":
			intf.bindNat = c.getBindNat(a, name)
		case "routing":
			intf.routing = c.getRouting(a, name)
		case "reroute_permit":
			intf.reroutePermit = c.tryNetworkRefList(a, v6, name)
		case "no_check":
			intf.noCheck = c.getFlag(a, name)
		default:
			if m := c.addIntfNat(a, nat, v6, name); m != nil {
				nat = m
			} else if strings.HasPrefix(a.Name, "secondary:") {
				name2 := a.Name[len("secondary:"):]
				intf := new(routerIntf)
				intf.name = name + "." + name2
				sCtx := a.Name + " of " + name
				l := c.getComplexValue(a, name)
				for _, a2 := range l {
					switch a2.Name {
					case "ip":
						intf.ip = c.getIp(a2, v6, sCtx)
					default:
						c.err("Unexpected attribute in %s: %s", sCtx, a2.Name)
					}
				}
				if !intf.ip.IsValid() {
					c.err("Missing IP in %s", sCtx)
					intf.ipType = shortIP
				}
				secondaryList.push(intf)
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}

	if l3Name == v.Name {
		intf.loopback = true
		intf.isLayer3 = true
		if r.model.class == "ASA" {
			if hwName != "device" {
				c.err(
					"Layer3 %s must use 'hardware' named 'device' for model 'ASA'",
					intf)
			}
		}
		if !ipGiven {
			c.err("Layer3 %s must have IP address", intf)
		}
		if secondaryList != nil || virtual != nil {
			c.err("Layer3 %s must not have secondary or virtual IP", intf)
			secondaryList = nil
			virtual = nil
		}
	}

	// Interface at bridged network
	// - without IP is interface of bridge,
	// - with IP (or unnumbered / negotiated) is interface of router.
	if !ipGiven &&
		intf.ipType != unnumberedIP &&
		intf.ipType != negotiatedIP &&
		strings.Contains(iName, "/") &&
		r.managed != "" {

		intf.ipType = bridgedIP
	}

	// Check spoke before adding virtual interface to secondaryList.
	if intf.spoke != nil {
		if secondaryList != nil {
			c.err("%s with attribute 'spoke' must not have secondary interfaces",
				intf)
			secondaryList = nil
		}
		if intf.hub != nil {
			c.err("%s with attribute 'spoke' must not have attribute 'hub'",
				intf)
		}
	} else if intf.id != "" {
		intf.id = ""
		c.warn("Ignoring attribute 'id' only valid with 'spoke' at %s", intf)
	}

	// Swap virtual interface and main interface
	// or take virtual interface as main interface if no main IP available.
	// Subsequent code becomes simpler if virtual interface is main interface.
	if virtual != nil {
		switch intf.ipType {
		case unnumberedIP:
			c.err("No virtual IP supported for unnumbered %s", name)
		case negotiatedIP:
			c.err("No virtual IP supported for negotiated %s", name)
		case bridgedIP:
			c.err("No virtual IP supported for bridged %s", name)
		default:
			if intf.ip.IsValid() {

				// Move main IP to secondary.
				secondary := new(routerIntf)
				secondary.name = intf.name
				secondary.ip = intf.ip
				secondaryList.push(secondary)

				// But we need the original main interface
				// when handling auto interfaces.
				intf.origMain = secondary
			}
		}
		if nat != nil {
			c.err("%s with virtual interface must not use attribute 'nat'",
				name)
		}
		if intf.hub != nil {
			c.err("%s with virtual interface must not use attribute 'hub'",
				name)
		}
		if intf.spoke != nil {
			c.err("%s with virtual interface must not use attribute 'spoke'",
				name)
		}
		intf.name = virtual.name
		intf.ip = virtual.ip
		intf.redundant = virtual.redundant
		intf.redundancyType = virtual.redundancyType
		intf.redundancyId = virtual.redundancyId
	} else if !ipGiven && intf.ipType == hasIP {
		intf.ipType = shortIP
	}
	if nat != nil && !ipGiven {
		c.err("No NAT supported for %s without IP", name)
	}

	typ := ""
	check := func(p bool, a string) {
		if p {
			c.err("Attribute '%s' not supported for %s %s", a, typ, name)
		}
	}
	if intf.ipType == bridgedIP {
		typ = "bridged"
		check(intf.owner != nil, "owner")
		check(intf.loopback, "loopback")
		check(vip, "vip")
	} else if vip {
		// Attribute 'vip' is an alias for 'loopback'.
		typ = "'vip'"
		intf.loopback = true
	} else if intf.loopback && !intf.isLayer3 {
		typ = "loopback"
	}
	if typ != "" {
		if secondaryList != nil {
			c.err("Secondary or virtual IP not supported for %s %s", typ, name)
			secondaryList = nil
			intf.origMain = nil // From virtual interface
		}

		// Most attributes are invalid for loopback interface.
		check(intf.noInAcl, "no_in_acl")
		check(intf.noCheck, "no_check")
		check(intf.id != "", "id")
		check(intf.hub != nil, "hub")
		check(intf.spoke != nil, "spoke")
		check(intf.dhcpClient, "dhcp_client")
		check(intf.dhcpServer, "dhcp_server")
		check(intf.routing != nil, "routing")
		check(intf.reroutePermit != nil, "reroute_permit")
		switch intf.ipType {
		case unnumberedIP:
			c.err("Attribute 'unnumbered' not supported for %s %s", typ, name)
		case negotiatedIP:
			c.err("Attribute 'negotiated' not supported for %s %s", typ, name)
		case shortIP:
			c.err("%s %s must have IP address", typ, name)
		}
	}
	if subnetOf != nil && !intf.loopback {
		c.err("Attribute 'subnet_of' must not be used at %s\n"+
			" It is only valid together with attribute 'loopback'", name)
	}
	if intf.noCheck && (intf.hub == nil || !r.model.doAuth) {
		intf.noCheck = false
		c.warn("Ignoring attribute 'no_check' at %s", intf)
	}
	if secondaryList != nil {
		if intf.ipType != hasIP {
			c.err("%s without IP address must not have secondary address", intf)
			secondaryList = nil
		}
	}
	if r.managed != "" {

		// Managed router must not have short interface.
		if intf.ipType == shortIP {
			c.err("Short definition of %s not allowed", name)
		}

		// Interface of managed router needs to have a hardware name.
		if hwName == "" {
			c.err("Missing 'hardware' for %s", name)

			// Prevent further errors.
			hwName = "unknown"
		}

		hw := hwMap[hwName]
		if hw == nil {
			hw = &hardware{name: hwName, loopback: true}
			hwMap[hwName] = hw
			r.hardware = append(r.hardware, hw)
		}
		// Hardware keeps attribute .loopback only if all
		// interfaces have attribute .loopback.
		if !intf.loopback {
			hw.loopback = false
		}

		// Remember, which logical interfaces are bound
		// to which hardware.
		hw.interfaces.push(intf)
		intf.hardware = hw
		for _, s := range secondaryList {
			s.hardware = hw
		}

		// Interface of managed router must not have individual owner,
		// because whole device is managed from one place.
		if intf.owner != nil {
			c.warn("Ignoring attribute 'owner' at managed %s", intf)
			intf.owner = nil
		}

		// Attribute 'vip' only supported at unmanaged router.
		if vip {
			c.err("Must not use attribute 'vip' at %s of managed router", name)
		}

		// Don't allow 'routing=manual' at single interface, because
		// approve would remove manual routes otherwise.
		// Approve only leaves routes unchanged, if Netspoc generates
		// no routes at all.
		if rt := intf.routing; rt != nil && rt.name == "manual" {
			c.warn("'routing=manual' must only be applied to router, not to %s",
				intf)
		}

		if l := intf.hub; l != nil {
			if intf.ipType != hasIP {
				c.err("Crypto hub %s must have IP address", intf)
			}
			if intf.bindNat != nil {
				c.err("Must not use 'bind_nat' at crypto hub %s\n"+
					" Move 'bind_nat' to crypto definition instead", intf)
			}
			for _, cr := range l {
				if cr.hub != nil {
					c.err("Must use 'hub = %s' exactly once, not at both\n"+
						" - %s\n"+
						" - %s", cr.name, cr.hub, intf)
				} else {
					cr.hub = intf
				}
			}
		}
	} else {
		// Unmanaged device.
		if intf.bindNat != nil {
			r.semiManaged = true
		}
		if intf.reroutePermit != nil {
			intf.reroutePermit = nil
			c.warn("Ignoring attribute 'reroute_permit' at unmanaged %s", intf)
		}
		if intf.hub != nil {
			c.warn("Ignoring attribute 'hub' at unmanaged %s", intf)
			intf.hub = nil
		}
	}

	intf.secondaryIntfs = secondaryList
	for _, s := range secondaryList {
		s.mainIntf = intf
		s.bindNat = intf.bindNat
		s.routing = intf.routing
	}

	// Automatically create a network for loopback interface.
	if intf.loopback {
		var shortName string
		var fullName string

		// Special handling needed for virtual loopback interfaces.
		// The created network needs to be shared among a group of
		// interfaces.
		if intf.redundant {

			// Shared virtual loopback network gets name
			// 'virtual:netname'. Don't use standard name to prevent
			// network from getting referenced from rules.
			shortName = "virtual:" + nName
			fullName = "network:" + shortName
		} else {

			// Single loopback network needs not to get an unique name.
			// Take an invalid name 'router.loopback' to prevent name
			// clashes with real networks or other loopback networks.
			fullName = intf.name
			shortName = fullName[len("interface:"):]
		}
		var n *network
		if intf.redundant {
			n = c.symTable.network[shortName]
		}
		if n == nil {
			n = new(network)
			n.name = fullName
			n.ipp = netip.PrefixFrom(intf.ip, getHostPrefix(v6))

			// Mark as automatically created.
			n.loopback = true
			n.subnetOf = subnetOf
			n.isLayer3 = intf.isLayer3
			n.ipV6 = v6

			// Move NAT definition to loopback network.
			n.nat = nat

			if intf.redundant {
				c.symTable.network[shortName] = n
			}
		}
		intf.network = n
		n.interfaces.push(intf)
	} else {
		// Link interface with network.
		n := c.symTable.network[nName]
		if n == nil {
			c.err("Referencing undefined network:%s from %s", nName, name)
		} else {
			n.interfaces.push(intf)
			for _, intf := range append(intfList{intf}, secondaryList...) {
				intf.network = n
				if intf.ipType != shortIP && (!ipGiven || intf.ip.IsValid()) {
					c.checkInterfaceIp(intf, n)
				}
			}
		}

		// Non loopback interface must use simple NAT with single IP
		// and without any NAT attributes.
		if len(nat) != 0 {
			intf.nat = make(map[string]netip.Addr)
			for tag, info := range nat {
				// Reject all non IP NAT attributes.
				// 'hidden' and 'identity' always set 'dynamic'.
				if info.dynamic {
					c.err("Only 'ip' allowed in nat:%s of %s", tag, intf)
				} else {
					intf.nat[tag] = info.ipp.Addr()
				}
			}
		}
	}

	// Link interface with router and vice versa.
	r.interfaces.push(intf)
	for _, intf := range append(intfList{intf}, secondaryList...) {
		intf.router = r
		intf.ipV6 = r.ipV6
		name := intf.name
		iName := name[len("interface:"):]
		if _, found := c.symTable.routerIntf[iName]; found {
			c.err("Duplicate definition of %s in %s", name, r)
		}
		c.symTable.routerIntf[iName] = intf
	}
}

func (c *spoc) setupService(v *ast.Service) {
	name := v.Name
	v6 := v.IPV6
	sName := name[len("service:"):]
	sv := c.symTable.service[sName]
	sv.name = name
	sv.ipV6 = v6
	if d := v.Description; d != nil {
		sv.description = strings.TrimSuffix(strings.TrimSpace(d.Text), ";")
	}
	for _, a := range v.Attributes {
		switch a.Name {
		case "identical_body":
			sv.identicalBody =
				c.tryServiceRefList(a, name)
		case "overlaps":
			sv.overlaps = c.tryServiceRefList(a, name)
		case "multi_owner":
			sv.multiOwner = c.getFlag(a, name)
		case "unknown_owner":
			sv.unknownOwner = c.getFlag(a, name)
		case "has_unenforceable":
			sv.hasUnenforceable = c.getFlag(a, name)
		case "disabled":
			sv.disabled = c.getFlag(a, name)
		case "disable_at":
			sv.disableAt = c.getSingleValue(a, name)
			if c.dateIsReached(sv.disableAt, "'disable_at' of "+name) {
				sv.disabled = true
			}
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	sv.foreach = v.Foreach
	sv.user = v.User.Elements
	userUserCount := 0
	for _, v2 := range v.Rules {
		ru := new(unexpRule)
		ru.service = sv
		if v2.Deny {
			ru.action = "deny"
		} else {
			ru.action = "permit"
		}
		ru.src = v2.Src.Elements
		ru.dst = v2.Dst.Elements
		srcUser := c.checkUserInUnion(ru.src, "'src' of "+name)
		dstUser := c.checkUserInUnion(ru.dst, "'dst' of "+name)
		if !(srcUser || dstUser) {
			c.err("Each rule of %s must use keyword 'user'", name)
		}
		if sv.foreach && !(srcUser && dstUser) {
			c.warn(
				"Each rule of %s should reference 'user' in 'src' and 'dst'\n"+
					" because service has keyword 'foreach'", name)
		}
		if srcUser && dstUser {
			ru.hasUser = "both"
			userUserCount++
		} else if srcUser {
			ru.hasUser = "src"
		} else {
			ru.hasUser = "dst"
		}
		ru.prt =
			c.expandProtocolsCheckV4V6(c.getValueList(v2.Prt, name), v6, name)
		if a2 := v2.Log; a2 != nil {
			l := c.getValueList(a2, name)
			l = c.checkLog(l, name)
			ru.log = strings.Join(l, " ")
		}
		sv.rules = append(sv.rules, ru)
	}
	if len(sv.rules) == 0 {
		c.err("Must not define %s without any rules", name)
	} else if userUserCount > 0 && len(sv.rules) != userUserCount {
		c.err("Must not define %s having both user-user rule and normal rule",
			name)
	}
}

// Normalize list of log tags.
// - Sort tags,
// - remove duplicate elements and
// - remove unknown tags, not defined at any router.
func (c *spoc) checkLog(l stringList, ctx string) stringList {
	var valid stringList
	prev := ""
	sort.Strings(l)
	for _, tag := range l {
		if tag == prev {
			c.warn("Duplicate '%s' in log of %s", tag, ctx)
		} else if !c.symTable.knownLog[tag] {
			c.warn("Ignoring unknown '%s' in log of %s", tag, ctx)
		} else {
			prev = tag
			valid.push(tag)
		}
	}
	return valid
}

func (c *spoc) checkUserInUnion(l []ast.Element, ctx string) bool {
	count := c.countUser(l, ctx)
	if !(count == 0 || count == len(l)) {
		c.err("The sub-expressions of union in %s equally must\n"+
			" either reference 'user' or must not reference 'user'", ctx)
	}
	return count > 0
}

func (c *spoc) checkUserInIntersection(l []ast.Element, ctx string) bool {
	return c.countUser(l, ctx) > 0
}

func (c *spoc) countUser(l []ast.Element, ctx string) int {
	count := 0
	for _, el := range l {
		if c.hasUser(el, ctx) {
			count++
		}
	}
	return count
}

func (c *spoc) hasUser(el ast.Element, ctx string) bool {
	switch x := el.(type) {
	case *ast.User:
		return true
	case ast.AutoElem:
		return c.checkUserInUnion(x.GetElements(), ctx)
	case *ast.Intersection:
		return c.checkUserInIntersection(x.Elements, ctx)
	case *ast.Complement:
		return c.hasUser(x.Element, ctx)
	default:
		return false
	}
}

func splitTypedName(s string) (string, string) {
	typ, name, _ := strings.Cut(s, ":")
	return typ, name
}

// Make ID unique by appending name of enclosing network.
func fullHostname(hName, nName string) string {
	if strings.HasPrefix(hName, "host:id:") {
		hName += "." + nName
	}
	return hName
}

func (c *spoc) checkDuplicate(l []ast.Toplevel) {
	seen := make(map[string]string)
	check := func(name, fName string) {
		if where := seen[name]; where != "" {
			if fName != where {
				where += " and " + fName
			}
			c.err("Duplicate definition of %s in %s", name, where)
		}
		seen[name] = fName
	}
	for _, a := range l {
		topName := a.GetName()
		fileName := a.FileName()
		switch x := a.(type) {
		case *ast.Network:
			nName := topName[len("network:"):]
			for _, a := range x.Hosts {
				full := fullHostname(a.Name, nName)
				check(full, fileName)
			}
		case *ast.Router:
			if x.IPV6 {
				topName = "IPv6 " + topName
			}
		}
		check(topName, fileName)
	}
}

func (c *spoc) checkDuplAttr(l []*ast.Attribute, ctx string) {
	seen := make(map[string]bool)
	for _, a := range l {
		if seen[a.Name] {
			c.err("Duplicate attribute '%s' in %s", a.Name, ctx)
		} else {
			seen[a.Name] = true
		}
	}
}

func emptyAttr(a *ast.Attribute) bool {
	return a.ComplexValue == nil && a.ValueList == nil
}

func (c *spoc) getFlag(a *ast.Attribute, ctx string) bool {
	if !emptyAttr(a) {
		c.err("No value expected for flag '%s' of %s", a.Name, ctx)
	}
	return true
}

func (c *spoc) getSingleValue(a *ast.Attribute, ctx string) string {
	if a.ComplexValue != nil || len(a.ValueList) != 1 {
		c.err("Single value expected in '%s' of %s", a.Name, ctx)
		return ""
	}
	return a.ValueList[0].Value
}

func (c *spoc) getValueList(a *ast.Attribute, ctx string) stringList {
	if a.ComplexValue != nil || len(a.ValueList) == 0 {
		c.err("List of values expected in '%s' of %s", a.Name, ctx)
		return nil
	}
	result := make(stringList, 0, len(a.ValueList))
	for _, v := range a.ValueList {
		result.push(v.Value)
	}
	return result
}

func (c *spoc) getComplexValue(
	a *ast.Attribute, ctx string) []*ast.Attribute {

	aCtx := a.Name
	if ctx != "" {
		aCtx += " of " + ctx
	}
	l := a.ComplexValue
	if l == nil || a.ValueList != nil {
		c.err("Structured value expected in '%s'", aCtx)
	}
	c.checkDuplAttr(l, aCtx)
	return l
}

func (c *spoc) getBindNat(a *ast.Attribute, ctx string) []string {
	l := c.getValueList(a, ctx)
	sort.Strings(l)
	// Remove duplicates.
	var seen string
	j := 0
	for _, tag := range l {
		if tag == seen {
			c.warn("Duplicate '%s' in 'bind_nat' of %s", tag, ctx)
		} else {
			seen = tag
			l[j] = tag
			j++
		}
	}
	return l[:j]
}

func (c *spoc) getIdentifier(a *ast.Attribute, ctx string) string {
	v := c.getSingleValue(a, ctx)
	if !isSimpleName(v) {
		c.err("Invalid identifier in '%s' of %s: %s", a.Name, ctx, v)
	}
	return v
}

// Check for valid email address.
// Local part definition from wikipedia,
// without space and other quoted characters.
// Only 7 bit ASCII.
var emailRegex = regexp.MustCompile(
	"^[\\w.!#$%&\"*+\\/=?^_\\{|}~`-]+@[\\w.-]+$")

func (c *spoc) getEmailList(a *ast.Attribute, ctx string) []string {
	l := c.getValueList(a, ctx)
	for i, m := range l {
		switch {
		case emailRegex.MatchString(m):
		case m == "guest":
		case a.Name == "watchers":
			if loc, dom, found := strings.Cut(m, "@"); found {
				if loc == "[all]" && isDomain(dom) {
					break
				}
			}
			fallthrough
		default:
			c.err("Invalid email address (ASCII only) in %s of %s: %s",
				a.Name, ctx, m)
		}
		l[i] = strings.ToLower(m)
	}
	return c.removeDupl(l, a.Name+" of "+ctx)
}

// Setup standard time units with different names and plural forms.
var timeunits = map[string]int{
	"sec":    1,
	"second": 1,
	"min":    60,
	"minute": 60,
	"hour":   3600,
	"day":    86400,
}

func init() {
	for k, v := range timeunits {
		timeunits[k+"s"] = v
	}
}

// Read time value in different units, return seconds.
func (c *spoc) getTimeVal(a *ast.Attribute, ctx string) int {
	v := c.getSingleValue(a, ctx)
	l := strings.Split(v, " ")
	bad := func() int {
		c.err("Expected 'NUM sec|min|hour|day' in '%s' of %s", a.Name, ctx)
		return -1
	}
	if len(l) != 2 {
		return bad()
	}
	i, err := strconv.Atoi(l[0])
	if err != nil || i < 0 {
		return bad()
	}
	unit := l[1]
	factor, found := timeunits[unit]
	if !found {
		return bad()
	}
	return i * factor
}

func (c *spoc) getTimeKilobytesPair(a *ast.Attribute, ctx string) *[2]int {
	v := c.getSingleValue(a, ctx)
	l := strings.Split(v, " ")
	bad := func() int {
		c.err("Expected '[NUM sec|min|hour|day] [NUM kilobytes]' in '%s' of %s",
			a.Name, ctx)
		return 0
	}
	time := func(v1, v2 string) int {
		i, err := strconv.Atoi(v1)
		if err != nil {
			return bad()
		}
		unit := v2
		factor, found := timeunits[unit]
		if !found {
			return bad()
		}
		return i * factor
	}
	kbytes := func(v1, v2 string) int {
		i, err := strconv.Atoi(v1)
		if err != nil {
			return bad()
		}
		if v2 != "kilobytes" {
			return bad()
		}
		return i
	}
	sec := -1
	kb := -1
	switch len(l) {
	case 2:
		if l[1] == "kilobytes" {
			kb = kbytes(l[0], l[1])
		} else {
			sec = time(l[0], l[1])
		}
	case 4:
		sec = time(l[0], l[1])
		kb = kbytes(l[2], l[3])
	default:
		bad()
	}
	return &[2]int{sec, kb}
}

func (c *spoc) removeDupl(l []string, ctx string) []string {
	seen := make(map[string]bool)
	var dupl stringList
	j := 0
	for _, s := range l {
		if seen[s] {
			dupl.push(s)
		} else {
			seen[s] = true
			l[j] = s
			j++
		}
	}
	if dupl != nil {
		c.err("Duplicates in %s: %s", ctx, strings.Join(dupl, ", "))
	}
	return l[:j]
}

func (c *spoc) getManaged(a *ast.Attribute, ctx string) string {
	if emptyAttr(a) {
		return "standard"
	}
	v := c.getSingleValue(a, ctx)
	switch v {
	case "secondary", "standard", "full", "primary", "local", "routing_only", "":
		return v
	}
	c.err("Invalid value for '%s' of %s: %s", a.Name, ctx, v)
	return ""
}

var routerInfo = map[string]*model{
	"IOS": &model{
		routing:         "IOS",
		filter:          "IOS",
		stateless:       true,
		statelessSelf:   true,
		statelessICMP:   true,
		inversedACLMask: true,
		canVRF:          true,
		logModifiers: map[string]string{
			"<empty>":   "log",
			"log-input": "log-input"},
		hasOutACL:        true,
		needProtect:      true,
		crypto:           "IOS",
		printRouterIntf:  true,
		vrfShareHardware: true,
		commentChar:      "!",
	},
	"NX-OS": {
		routing:          "NX-OS",
		filter:           "NX-OS",
		stateless:        true,
		statelessSelf:    true,
		statelessICMP:    true,
		canObjectgroup:   true,
		inversedACLMask:  true,
		usePrefix:        true,
		canVRF:           true,
		logModifiers:     map[string]string{"<empty>": "log"},
		hasOutACL:        true,
		needProtect:      true,
		printRouterIntf:  true,
		vrfShareHardware: true,
		commentChar:      "!",
	},
	"ASA": {
		routing: "ASA",
		filter:  "ASA",
		logModifiers: map[string]string{
			"<empty>":       "log",
			"emergencies":   "log 0",
			"alerts":        "log 1",
			"critical":      "log 2",
			"errors":        "log 3",
			"warnings":      "log 4",
			"notifications": "log 5",
			"informational": "log 6",
			"debugging":     "log 7",
			"disable":       "log disable",
		},
		statelessICMP:  true,
		hasOutACL:      true,
		aclUseRealIP:   true,
		canObjectgroup: true,
		canDynCrypto:   true,
		crypto:         "ASA",
		noCryptoFilter: true,
		commentChar:    "!",
		needACL:        true,
		noACLself:      true,
	},
	"PAN-OS": {
		routing: "",
		filter:  "PAN-OS",
		logModifiers: map[string]string{
			"start":    "start",
			"end":      "end",
			"setting:": ":insert",
		},
		canMultiLog:            true,
		hasIoACL:               true,
		canObjectgroup:         true,
		canVRF:                 true,
		needManagementInstance: true,
		needVRF:                true,
		noACLself:              true,
	},
	"NSX": {
		routing: "",
		filter:  "NSX",
		logModifiers: map[string]string{
			"<empty>": "logged",
			"tag:":    ":insert",
		},
		canObjectgroup:         true,
		canVRF:                 true,
		needManagementInstance: true,
		needVRF:                true,
		noACLself:              true,
		noSharedHardware:       true,
	},
	"Linux": {
		routing:     "iproute",
		filter:      "iptables",
		hasIoACL:    true,
		commentChar: "#",
	},
}

func init() {
	for name, info := range routerInfo {
		// Is changed for model with extension. Used in error messages.
		info.name = name
		// Is left unchanged with extensions. Used in header of generated files.
		info.class = name
	}
}

func (c *spoc) getModel(a *ast.Attribute, ctx string) *model {
	l := c.getValueList(a, ctx)
	m := l[0]
	attributes := l[1:]
	orig, found := routerInfo[m]
	if !found {
		c.err("Unknown model in %s: %s", ctx, m)

		// Prevent further errors.
		return &model{name: m}
	}
	info := *orig
	if len(attributes) > 0 {
		add := ""
		for _, att := range attributes {
			add += ", " + att
			switch m {
			case "IOS":
				switch att {
				case "EZVPN":
					info.crypto = "EZVPN"
				case "FW":
					info.stateless = false
				default:
					goto FAIL
				}
			case "ASA":
				switch att {
				case "VPN":
					info.crypto = "ASA_VPN"
					info.doAuth = true
				case "CONTEXT":
					info.cryptoInContext = true
				case "EZVPN":
					info.crypto = "ASA_EZVPN"
				default:
					goto FAIL
				}
			case "NSX":
				switch att {
				case "T0":
					info.tier = "0"
				case "T1":
					info.tier = "1"
				default:
					goto FAIL
				}
			default:
				goto FAIL
			}
			continue
		FAIL:
			c.err("Unknown extension in '%s' of %s: %s", a.Name, ctx, att)
		}
		info.name += add
	}
	return &info
}

// Definition of dynamic routing protocols.
var routingInfo = map[string]*mcastProto{
	"EIGRP": &mcastProto{
		name: "EIGRP",
		prt:  &proto{proto: "88", name: "proto 88"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.10"}},
			v6: multicast{ips: []string{"ff02::a"}}},
	},
	"OSPF": &mcastProto{
		name: "OSPF",
		prt:  &proto{proto: "89", name: "proto 89"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.5", "224.0.0.6"}},
			v6: multicast{ips: []string{"ff02::5", "ff02::6"}}},
	},
	"RIPv2": &mcastProto{
		name: "RIP",
		prt:  &proto{proto: "udp", ports: [2]int{520, 520}, name: "udp 520"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.9"}},
			v6: multicast{ips: []string{"ff02::9"}}},
	},
	"dynamic": &mcastProto{name: "dynamic"},

	// Identical to 'dynamic', but must only be applied to router, not
	// to routerIntf.
	"manual": &mcastProto{name: "manual"},
}

func init() {
	addMcastNetworks(routingInfo)
}

func (c *spoc) getRouting(a *ast.Attribute, ctx string) *mcastProto {
	v := c.getSingleValue(a, ctx)
	r := routingInfo[v]
	if r == nil {
		c.err("Unknown routing protocol in '%s' of %s", a.Name, ctx)
	}
	return r
}

// Definition of redundancy protocols.
var xxrpInfo = map[string]*mcastProto{
	"VRRP": &mcastProto{
		prt: &proto{proto: "112", name: "proto 112"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.18"}},
			v6: multicast{ips: []string{"ff02::12"}}},
	},
	"HSRP": &mcastProto{
		prt: &proto{proto: "udp", ports: [2]int{1985, 1985}, name: "udp 1985"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.2"}},

			// No official IPv6 multicast address for HSRP available,
			// therefore using IPv4 equivalent.
			v6: multicast{ips: []string{"::e000:2"}}},
	},
	"HSRPv2": &mcastProto{
		prt: &proto{proto: "udp", ports: [2]int{1985, 1985}, name: "udp 1985"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.102"}},
			v6: multicast{ips: []string{"ff02::66"}}},
	},
}

func init() {
	addMcastNetworks(xxrpInfo)
}

func addMcastNetworks(info map[string]*mcastProto) {
	for _, mp := range info {
		process := func(m *multicast, v6 bool) {
			l := make([]*network, len(m.ips))
			for i, s := range m.ips {
				ip := netip.MustParseAddr(s)
				ipp := netip.PrefixFrom(ip, getHostPrefix(v6))
				l[i] = &network{
					ipp:         ipp,
					withStdAddr: withStdAddr{stdAddr: ipp.String()},
				}
			}
			m.networks = l
		}
		process(&mp.v4, false)
		process(&mp.v6, true)
	}
}

func (c *spoc) getVirtual(a *ast.Attribute, v6 bool, ctx string) *routerIntf {
	virtual := new(routerIntf)
	virtual.name = ctx + ".virtual"
	virtual.redundant = true
	vCtx := "'" + a.Name + "' of " + ctx
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "ip":
			virtual.ip = c.getIp(a2, v6, vCtx)
		case "type":
			t := c.getSingleValue(a2, vCtx)
			p := xxrpInfo[t]
			if p == nil {
				c.err("Unknown redundancy protocol in %s", vCtx)
			}
			virtual.redundancyType = p
		case "id":
			id := c.getSingleValue(a2, vCtx)
			num, err := strconv.Atoi(id)
			if err != nil {
				c.err("Redundancy ID must be numeric in %s", vCtx)
			} else if !(num >= 0 && num < 256) {
				c.err("Redundancy ID must be < 256 in %s", vCtx)
			}
			virtual.redundancyId = id
		default:
			c.err("Unexpected attribute in %s: %s", vCtx, a2.Name)
		}
	}
	if !virtual.ip.IsValid() {
		c.err("Missing IP in %s", vCtx)
		return nil
	}
	if virtual.redundancyId != "" && virtual.redundancyType == nil {
		c.err("Redundancy ID is given without redundancy protocol in %s",
			vCtx)
	}
	return virtual
}

func isDomain(n string) bool {
	for _, part := range strings.Split(n, ".") {
		if !isSimpleName(part) {
			return false
		}
	}
	return n != ""
}

func isIdHostname(id string) bool {
	i := strings.Index(id, "@")
	// Leading "@" is ok.
	return (i <= 0 || isDomain(id[:i])) && isDomain(id[i+1:])
}

func isSimpleName(n string) bool {
	return n != "" && !strings.ContainsAny(n, ".:/@")
}

func (c *spoc) getIp(a *ast.Attribute, v6 bool, ctx string) netip.Addr {
	return c.convIP(c.getSingleValue(a, ctx), v6, a.Name, ctx)
}

func (c *spoc) getIpList(a *ast.Attribute, v6 bool, ctx string) []netip.Addr {
	var result []netip.Addr
	for _, v := range c.getValueList(a, ctx) {
		result = append(result, c.convIP(v, v6, a.Name, ctx))
	}
	return result
}

func (c *spoc) getIpRange(
	a *ast.Attribute, v6 bool, ctx string) netipx.IPRange {

	v := c.getSingleValue(a, ctx)
	v = strings.Replace(v, " - ", "-", 1)
	rg, err := netipx.ParseIPRange(v)
	if err != nil {
		c.err("Invalid IP range in %s", ctx)
		return rg
	}
	c.checkVxIP(rg.From(), v6, a.Name, ctx)
	return rg
}

func (c *spoc) getIpPrefix(
	a *ast.Attribute, v6 bool, ctx string) netip.Prefix {

	v := c.getSingleValue(a, ctx)
	return c.convIpPrefix(v, v6, a.Name, ctx)
}

func (c *spoc) getIpPrefixList(
	a *ast.Attribute, v6 bool, ctx string) []netip.Prefix {

	var result []netip.Prefix
	for _, v := range c.getValueList(a, ctx) {
		result = append(result, c.convIpPrefix(v, v6, a.Name, ctx))
	}
	return result
}

func (c *spoc) convIpPrefix(
	s string, v6 bool, name, ctx string) netip.Prefix {

	n, err := netip.ParsePrefix(s)
	if err != nil {
		c.err("Invalid CIDR address: %s in '%s' of %s", s, name, ctx)
	} else if n.Masked() != n {
		c.err("IP and mask of %s don't match in '%s' of %s", s, name, ctx)
	}
	c.checkVxIP(n.Addr(), v6, name, ctx)
	return n
}

func (c *spoc) convIP(s string, v6 bool, name, ctx string) netip.Addr {
	ip, err := netip.ParseAddr(s)
	if err != nil {
		c.err("Invalid IP address in '%s' of %s", name, ctx)
		return ip
	}
	c.checkVxIP(ip, v6, name, ctx)
	return ip
}

func (c *spoc) checkVxIP(ip netip.Addr, v6 bool, name, ctx string) {
	if v6 {
		if ip.Is4() {
			c.err("IPv6 address expected in '%s' of %s", name, ctx)
		}
	} else if ip.Is6() {
		c.err("IPv4 address expected in '%s' of %s", name, ctx)
	}
}

// Check if given date has been reached already.
var dateRegex = regexp.MustCompile(`^(\d\d\d\d-\d\d-\d\d)$`)

func (c *spoc) dateIsReached(s, ctx string) bool {
	l := dateRegex.FindStringSubmatch(s)
	if l == nil {
		c.err("Date expected as yyyy-mm-dd in %s", ctx)
		return false
	}
	date, err := time.ParseInLocation("2006-01-02", s, time.Local)
	if err != nil {
		c.err("Invalid date in %s: %v", ctx, err)
		return false
	}
	return time.Now().After(date)
}

func (c *spoc) getNetworkRef(a *ast.Attribute, v6 bool, ctx string) *network {
	return c.lookupNetworkRef(a, v6, ctx, false)
}

func (c *spoc) tryNetworkRef(a *ast.Attribute, v6 bool, ctx string) *network {

	return c.lookupNetworkRef(a, v6, ctx, true)
}

func (c *spoc) lookupNetworkRef(
	a *ast.Attribute, v6 bool, ctx string,
	warn bool) *network {

	typ, name := c.getTypedName(a, ctx)
	if typ == "" {
		return nil
	}
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "network" {
		c.err("Must only use network name in %s", ctx2)
		return nil
	}
	n := c.symTable.network[name]
	if n == nil {
		f := c.err
		if warn {
			f = c.warn
		}
		f("Referencing undefined network:%s in %s", name, ctx2)
		return nil
	}
	c.checkV4V6CrossRef(n, v6, ctx2)
	return n
}

func (c *spoc) tryNetworkRefList(
	a *ast.Attribute, v6 bool, ctx string) netList {

	l := c.getValueList(a, ctx)
	result := make(netList, 0, len(l))
	ctx2 := "'" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "network:")
		if len(name) == len(v) {
			c.err("Expected type 'network:' in %s", ctx2)
		} else if n, found := c.symTable.network[name]; found {
			c.checkV4V6CrossRef(n, v6, ctx2)
			result = append(result, n)
		} else {
			c.warn("Ignoring undefined network:%s in %s", name, ctx2)
		}
	}
	return result
}

func (c *spoc) tryHostRef(
	a *ast.Attribute, v6 bool, ctx string) *host {

	typ, name := c.getTypedName(a, ctx)
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "host" {
		c.err("Expected type 'host:' in %s", ctx2)
		return nil
	}
	h := c.symTable.host[name]
	if h == nil {
		c.warn("Ignoring undefined host:%s in %s", name, ctx2)
		return nil
	}
	c.checkV4V6CrossRef(h, v6, ctx2)
	return h
}

func (c *spoc) tryRouterRef(a *ast.Attribute, v6 bool, ctx string) *router {

	typ, name := c.getTypedName(a, ctx)
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "router" {
		c.err("Expected type 'router:' in %s", ctx2)
		return nil
	}
	r := c.getRouter(name, v6)
	if r == nil {
		c.warn("Ignoring undefined router:%s in %s", name, ctx2)
		return nil
	}
	return r
}

func (c *spoc) getRouter(name string, v6 bool) *router {
	if v6 {
		return c.symTable.router6[name]
	} else {
		return c.symTable.router[name]
	}
}

func (c *spoc) getTypedName(a *ast.Attribute, ctx string) (string, string) {
	v := c.getSingleValue(a, ctx)
	typ, name, found := strings.Cut(v, ":")
	if !found {
		c.err("Typed name expected in '%s' of %s", a.Name, ctx)
		return "", ""
	}
	return typ, name
}

func (c *spoc) getRealOwnerRef(a *ast.Attribute, ctx string) *owner {
	o := c.tryOwnerRef(a, ctx)
	if o != nil {
		if o.admins == nil {
			c.err("Missing attribute 'admins' in %s of %s", o, ctx)
			o.admins = make([]string, 0)
		}
		if o.onlyWatch {
			c.err("%s with attribute 'only_watch' must only be used at area,\n"+
				" not at %s", o, ctx)
			o.onlyWatch = false
		}
	}
	return o
}

func (c *spoc) tryOwnerRef(a *ast.Attribute, ctx string) *owner {

	name := c.getSingleValue(a, ctx)
	o := c.symTable.owner[name]
	if o == nil {
		c.warn("Ignoring undefined owner:%s of %s", name, ctx)
	} else {
		o.isUsed = true
	}
	return o
}

func (c *spoc) getIsakmpRef(a *ast.Attribute, ctx string) *isakmp {

	typ, name := c.getTypedName(a, ctx)
	if typ != "isakmp" {
		c.err("Expected type 'isakmp:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	is := c.symTable.isakmp[name]
	if is == nil {
		c.err("Can't resolve reference to isakmp:%s in %s", name, ctx)
	}
	return is
}

func (c *spoc) getIpsecRef(a *ast.Attribute, ctx string) *ipsec {
	typ, name := c.getTypedName(a, ctx)
	if typ != "ipsec" {
		c.err("Expected type 'ipsec:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	is := c.symTable.ipsec[name]
	if is == nil {
		c.err("Can't resolve reference to ipsec:%s in %s", name, ctx)
	}
	return is
}

func (c *spoc) getCryptoRef(a *ast.Attribute, ctx string) *crypto {
	typ, name := c.getTypedName(a, ctx)
	if typ != "crypto" {
		c.err("Expected type 'crypto:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	cr := c.symTable.crypto[name]
	if cr == nil {
		c.err("Can't resolve reference to crypto:%s in '%s' of %s",
			name, a.Name, ctx)
	}
	return cr
}

func (c *spoc) getCryptoRefList(a *ast.Attribute, ctx string) []*crypto {
	l := c.getValueList(a, ctx)
	result := make([]*crypto, 0, len(l))
	ctx2 := "'" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "crypto:")
		if len(name) == len(v) {
			c.err("Expected type 'crypto:' in %s", ctx2)
		} else if cr, found := c.symTable.crypto[name]; found {
			result = append(result, cr)
		} else {
			c.err("Can't resolve reference to crypto:%s in %s", name, ctx2)
		}
	}
	return result
}

func (c *spoc) tryServiceRefList(a *ast.Attribute, ctx string) []*service {
	l := c.getValueList(a, ctx)
	result := make([]*service, 0, len(l))
	ctx2 := "attribute '" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "service:")
		if len(name) == len(v) {
			c.err("Expected type 'service:' in %s", ctx2)
		} else if s, found := c.symTable.service[name]; found {
			result = append(result, s)
		} else {
			c.warn("Unknown '%s' in %s", v, ctx2)
		}
	}
	return result
}

func (c *spoc) getProtocolRef(name string, ctx string) *proto {
	p := c.symTable.protocol[name]
	if p == nil {
		c.err("Can't resolve reference to protocol:%s in %s", name, ctx)
	} else {
		p.isUsed = true
	}
	return p
}

func (c *spoc) getProtocolList(
	a *ast.Attribute, v6 bool, ctx string) protoList {

	l := c.getValueList(a, ctx)
	ctx2 := a.Name + " of " + ctx
	return c.expandProtocolsCheckV4V6(l, v6, ctx2)
}

func (c *spoc) expandProtocolsCheckV4V6(
	l stringList, v6 bool, ctx string) protoList {

	pl := c.expandProtocols(l, v6, ctx)
	for _, p := range pl {
		switch p.proto {
		case "icmpv6":
			if !v6 {
				c.err("%s must not be used in IPv4 %s", p.name, ctx)
			}
		case "icmp":
			if v6 {
				c.err("%s must not be used in IPv6 %s", p.name, ctx)
			}
		case "1":
			if !v6 {
				c.err("'proto 1' must not be used in %s, use 'icmp' instead",
					ctx)
			}
		case "58":
			if v6 {
				c.err("'proto 58' must not be used in %s, use 'icmpv6' instead",
					ctx)
			}
		}
	}
	return pl
}

func (c *spoc) expandProtocols(l stringList, v6 bool, ctx string) protoList {

	var result protoList
	for _, v := range l {
		if strings.HasPrefix(v, "protocol:") {
			name := v[len("protocol:"):]
			if p := c.getProtocolRef(name, ctx); p != nil {
				result.push(p)
			}
		} else if strings.HasPrefix(v, "protocolgroup:") {
			name := v[len("protocolgroup:"):]
			result = append(result, c.expandProtocolgroup(name, v6, ctx)...)
		} else {
			ctx2 := "'" + v + "' of " + ctx
			p := c.getSimpleProtocol(v, v6, ctx2)
			result.push(p)
		}
	}
	// Ignore duplicates
	seen := make(map[*proto]bool)
	j := 0
	for _, p := range result {
		pm := p
		if p2 := p.main; p2 != nil && p.modifiers == nil {
			pm = p2
		}
		if seen[pm] {
			c.warn("Ignoring duplicate '%s' in %s", pm.name, ctx)
		} else {
			result[j] = p
			j++
			seen[pm] = true
		}
	}
	return result[:j]
}

func (c *spoc) expandProtocolgroup(
	name string, v6 bool, ctx string) protoList {

	g, found := c.symTable.protocolgroup[name]
	if !found {
		c.err("Can't resolve reference to protocolgroup:%s in %s", name, ctx)
		return nil
	}
	if g.recursive {
		c.err("Found recursion in definition of %s", ctx)
	} else if !g.isUsed {
		g.isUsed = true
		g.recursive = true
		ctx2 := "protocolgroup:" + name
		g.elements = c.expandProtocols(g.list, v6, ctx2)
		g.recursive = false
	}
	return g.elements
}

func (c *spoc) cacheUnnamedProtocol(p *proto) *proto {
	name := genProtocolName(p)
	if cached, found := c.symTable.unnamedProto[name]; found {
		return cached
	}
	p.name = name
	c.symTable.unnamedProto[name] = p
	return p
}

// Creates a readable, unique name for passed protocol,
// e.g. "tcp 80" for { proto : "tcp", ports: [80, 80] }.
func genProtocolName(p *proto) string {
	pr := p.proto
	switch pr {
	case "ip":
		return pr
	case "tcp", "udp":
		n := p.ports
		return jcode.GenPortName(pr, n[0], n[1])
	case "icmp", "icmpv6":
		result := pr
		if p.icmpType != -1 {
			result += " " + strconv.Itoa(p.icmpType)
			if p.icmpCode != -1 {
				result += "/" + strconv.Itoa(p.icmpCode)
			}
		}
		return result
	default:
		return "proto " + pr
	}
}

func (c *spoc) getRadiusAttributes(a *ast.Attribute, ctx string) map[string]string {
	result := make(map[string]string)
	rCtx := a.Name + " of " + ctx
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		k := a2.Name
		if !isSimpleName(k) {
			c.err("Invalid identifier '%s' in %s", k, rCtx)
		}
		v := ""
		if len(a2.ValueList) == 1 {
			v = a2.ValueList[0].Value
		}
		result[k] = v
	}
	return result
}

func (c *spoc) getRouterAttributes(
	a *ast.Attribute, ar *area) routerAttributes {

	ctx := ar.name
	var r routerAttributes
	name := "router_attributes of " + ctx
	r.name = name
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "owner":
			r.owner = c.getRealOwnerRef(a2, name)
		case "policy_distribution_point":
			r.policyDistributionPoint = c.tryHostRef(a2, ar.ipV6, name)
		case "general_permit":
			r.generalPermit = c.getGeneralPermit(a2, ar.ipV6, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a2.Name)
		}
	}
	return r
}

func (c *spoc) getGeneralPermit(
	a *ast.Attribute, v6 bool, ctx string) protoList {

	l := c.getProtocolList(a, v6, ctx)
	for i, p := range l {
		// Check for protocols not valid for general_permit.
		// Don't allow port ranges. This wouldn't work, because
		// genReverseRules doesn't handle generally permitted protocols.
		var reason stringList
		srcRange := false
		if m := p.modifiers; m != nil {
			if m.srcRange == nil {
				reason.push("modifiers")
			} else {
				srcRange = true
			}
		}
		name := p.name
		if p2 := p.main; p2 != nil {
			p = p2
			l[i] = p
		}
		if srcRange ||
			p.ports[0] != 0 && !(p.ports[0] == 1 && p.ports[1] == 65535) {
			reason.push("ports")
		}
		if reason != nil {
			c.err("Must not use '%s' with %s in general_permit of %s",
				name, strings.Join(reason, " or "), ctx)
		}
	}
	// Sort protocols by name, so we can compare value lists of
	// attribute general_permit for redundancy during inheritance.
	sort.Slice(l, func(i, j int) bool { return l[i].name < l[j].name })
	return l
}

func (c *spoc) getLogModifiers(a *ast.Attribute, ctx string) string {
	if emptyAttr(a) {
		return "<empty>"
	}
	return strings.Join(c.getValueList(a, ctx), " ")
}

func (c *spoc) addLog(a *ast.Attribute, r *router) bool {
	if !strings.HasPrefix(a.Name, "log:") {
		return false
	}
	m := r.log
	if m == nil {
		m = make(map[string]string)
		r.log = m
	}
	name := a.Name[len("log:"):]
	c.symTable.knownLog[name] = true
	m[name] = c.getLogModifiers(a, r.name)
	return true
}

// Check log modifiers and transform to log code.
func (c *spoc) transformLog(name, modList string, r *router) string {
	knownMod := r.model.logModifiers
	if knownMod == nil {
		c.err("Must not use attribute '%s' at %s of model %s",
			name, r.name, r.model.name)
		return ""
	}
	l := strings.Split(modList, " ")
	if len(l) > 1 && !r.model.canMultiLog {
		c.err("Must not use multiple values for %s in %s of model %s",
			name, r.name, r.model.name)
		return ""
	}
	for i, mod := range l {
		k := mod
		// Check for KEY:VALUE
		if i := strings.Index(mod, ":"); i != -1 {
			k = mod[:i+1]
			if len(k) == len(mod) {
				c.err(
					"Must give some value after ':' in '%s' of %s in %s",
					mod, name, r.name)
			}
		}
		if v, found := knownMod[k]; found {
			if v == ":insert" {
				// Substitute special value ":insert" by original KEY:VALUE.
				v = mod
			}
			l[i] = v
			continue
		}

		// Show error message for unknown log tag.
		what := fmt.Sprintf("'%s = %s' at %s of model %s",
			name, mod, r.name, r.model.name)
		if len(knownMod) == 1 && knownMod["<empty>"] != "" {
			c.err("Unexpected %s\n Use '%s;' only.", what, name)
			continue
		}
		valid := maps.Keys(knownMod)
		sort.Strings(valid)
		oneOf := cond(r.model.canMultiLog, "", " one of")
		c.err("Invalid %s\n Expected%s: %s",
			what, oneOf, strings.Join(valid, "|"))
	}
	return strings.Join(l, " ")
}

func (c *spoc) addAttr(a *ast.Attribute, attr *attrStore, ctx string) bool {
	var k attrKey
	switch a.Name {
	default:
		return false
	case "overlaps":
		k = overlapsAttr
	case "identical_body":
		k = identicalBodyAttr
	case "unknown_owner":
		k = unknownOwnerAttr
	case "multi_owner":
		k = multiOwnerAttr
	case "has_unenforceable":
		k = hasUnenforceableAttr
	}
	v := c.getSingleValue(a, ctx)
	var at attrVal
	switch v {
	default:
		c.err("Expected 'restrict', 'enable' or 'ok' in '%s' of %s", a.Name, ctx)
	case "restrict":
		at = restrictVal
	case "enable":
		at = enableVal
	case "ok":
		at = okVal
	}
	attr[k] = at
	return true
}

func (c *spoc) addNetNat(
	a *ast.Attribute, m natTagMap, v6 bool, ctx string) natTagMap {

	return c.addXNat(a, m, v6, ctx, c.getIpPrefix)
}
func (c *spoc) addIntfNat(
	a *ast.Attribute, m natTagMap, v6 bool, ctx string) natTagMap {

	return c.addXNat(a, m, v6, ctx,
		func(a *ast.Attribute, v6 bool, ctx string) netip.Prefix {
			ip := c.getSingleValue(a, ctx)
			return netip.PrefixFrom(
				c.convIP(ip, v6, a.Name, ctx),
				getHostPrefix(v6),
			)
		})
}

func (c *spoc) addXNat(
	a *ast.Attribute, m natTagMap, v6 bool, ctx string,
	getIpX func(*ast.Attribute, bool, string) netip.Prefix,
) natTagMap {

	if !strings.HasPrefix(a.Name, "nat:") {
		return nil
	}
	tag := a.Name[len("nat:"):]
	nat := new(network)
	natCtx := a.Name + " of " + ctx
	ipGiven := false
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "ip":
			ipGiven = true
			nat.ipp = getIpX(a2, v6, natCtx)
		case "hidden":
			nat.hidden = c.getFlag(a2, natCtx)
			if len(l) != 1 {
				c.err("Hidden NAT must not use other attributes in %s", natCtx)
			}
			// This simplifies error checks for overlapping addresses.
			nat.dynamic = true
			// Provide an unusable address.
			nat.ipp = netip.PrefixFrom(getZeroIp(v6), getHostPrefix(v6))
		case "identity":
			nat.identity = c.getFlag(a2, natCtx)
			if len(l) != 1 {
				c.err("Identity NAT must not use other attributes in %s", natCtx)
			}
			nat.dynamic = true
		case "dynamic":
			nat.dynamic = c.getFlag(a2, natCtx)
		case "subnet_of":
			nat.subnetOf = c.tryNetworkRef(a2, v6, natCtx)
		default:
			c.err("Unexpected attribute in %s: %s", natCtx, a2.Name)
		}
	}
	if !nat.identity && !nat.hidden && !ipGiven {
		c.err("Missing IP address in %s", natCtx)
	}

	// Attribute .natTag is used later to look up static translation
	// of hosts inside a dynamically translated network.
	nat.natTag = tag

	nat.name = ctx
	nat.descr = "nat:" + tag + " of " + ctx
	if m == nil {
		m = make(natTagMap)
	}
	m[tag] = nat
	return m
}

func (c *spoc) addIPNat(a *ast.Attribute, m map[string]netip.Addr, v6 bool,
	ctx string) map[string]netip.Addr {

	if !strings.HasPrefix(a.Name, "nat:") {
		return nil
	}
	if m == nil {
		m = make(map[string]netip.Addr)
	}
	tag := a.Name[len("nat:"):]
	natCtx := a.Name + " of " + ctx
	l := c.getComplexValue(a, ctx)
	if len(l) != 1 || l[0].Name != "ip" {
		c.err("Expecting exactly one attribute 'ip' in %s", natCtx)
		return m
	}
	m[tag] = c.getIp(l[0], v6, natCtx)
	return m
}

func (c *spoc) checkInterfaceIp(intf *routerIntf, n *network) {
	if intf.ipType == unnumberedIP {
		if n.ipType != unnumberedIP {
			c.err("Unnumbered %s must not be linked to %s", intf, n)
		}
		return
	}
	if n.ipType == unnumberedIP {
		c.err("%s must not be linked to unnumbered %s", intf, n)
		return
	}
	if intf.ipType != hasIP {
		// Nothing to be checked: attribute 'bridged' is set automatically
		// for an interface without IP and linked to bridged network.
		return
	}

	ipp := n.ipp
	// Network has invalid IP address. Error was already shown.
	if !ipp.IsValid() {
		return
	}

	// Check compatibility of interface IP and network IP/mask.
	ip := intf.ip
	if !ipp.Contains(ip) {
		c.err("%s's IP doesn't match %s's IP/mask", intf, n)
	}
	if ipp.IsSingleIP() {
		c.warn("%s has address of its network.\n"+
			" Remove definition of %s and\n"+
			" add attribute 'loopback' at interface definition.",
			intf, n)
	} else if !n.ipV6 {

		// Check network and broadcast address only for IPv4,
		// but not for /31 IPv4 (see RFC 3021).
		if n.ipp.Bits() != 31 {
			if ip == n.ipp.Addr() {
				c.err("%s has address of its network", intf)
			}
			if ip == netipx.RangeOfPrefix(n.ipp).To() {
				c.err("%s has broadcast address", intf)
			}
		}
	}
}

// checkNoInAcl moves attribute 'no_in_acl'
// from interface to hardware	because ACLs operate on hardware, not on logic.
//
//	Marks hardware needing outgoing ACLs.
//
// Comment: Not more than one 'no_in_acl' interface per router allowed.
func (c *spoc) checkNoInAcl(r *router) {
	count := 0
	hasCrypto := false
	var rerouteIntf *routerIntf

	// Move attribute no_in_acl to hardware.
	for _, intf := range r.interfaces {
		if intf.spoke != nil || intf.hub != nil {
			hasCrypto = true
		}
		if intf.reroutePermit != nil && !intf.noInAcl {
			rerouteIntf = intf
		}
		if !intf.noInAcl {
			continue
		}
		hw := intf.hardware

		// Prevent duplicate error message.
		if hw.noInAcl {
			continue
		}
		hw.noInAcl = true

		// Assure max number of main interfaces at no_in_acl-hardware == 1.
		if len(hw.interfaces) != 1 {
			c.err("Only one logical interface allowed at hardware '%s' of %s\n"+
				" because of attribute 'no_in_acl'", hw.name, r)
		}
		count++

		// Reference no_in_acl interface in router attribute.
		r.noInAcl = intf
	}
	if count == 0 {
		return
	}

	// Assert maximum number of 'no_in_acl' interfaces per router
	if count != 1 {
		c.err("At most one interface of %s may use flag 'no_in_acl'", r)
	}

	// Assert router to support outgoing ACL
	if !r.model.hasOutACL {
		c.err("%s doesn't support outgoing ACL", r)
	}

	// reroute_permit would generate permit any -> networks,
	// but no_in_acl would generate permit any -> any anyway.
	if r.noInAcl.reroutePermit != nil {
		c.warn("Useless use of attribute 'reroute_permit' together with"+
			" 'no_in_acl' at %s", r.noInAcl.name)
	}

	// Must not use reroute_permit to network N together with no_in_acl.
	// In this case incoming traffic at no_in_acl interface
	// to network N wouldn't be filtered at all.
	if rerouteIntf != nil {
		c.err("Must not use attributes no_in_acl and reroute_permit"+
			" together at %s\n"+
			" Add incoming and outgoing ACL line in raw file instead.", r)
	}

	// Assert router not to take part in crypto tunnels.
	if hasCrypto {
		c.err(
			"Don't use attribute 'no_in_acl' together with crypto tunnel at %s",
			r)
	}

	// Mark other hardware with attribute 'needOutAcl'.
	for _, hw := range r.hardware {
		if !hw.noInAcl {
			hw.needOutAcl = true
		}
	}
}

// No traffic must traverse crypto interface.
// Hence split router into separate instances, one instance for each
// crypto interface.
// Split routers are tied by identical attribute .deviceName.
func (c *spoc) moveLockedIntf(intf *routerIntf) {
	orig := intf.router

	// Use different and uniqe name for each split router.
	name := "router:" + intf.name[len("interface:"):]
	cp := *orig
	cp.name = name
	cp.origRouter = orig
	cp.interfaces = intfList{intf}
	intf.router = &cp
	c.allRouters = append(c.allRouters, &cp)

	// Don't check fragment for reachability.
	cp.policyDistributionPoint = nil

	// radiusAttributes are only needed at origRouter, where crypto
	// tunnels are attached.
	cp.radiusAttributes = nil

	// Remove interface from old router.
	// Retain original interfaces.
	l := orig.interfaces
	if orig.origIntfs == nil {
		orig.origIntfs = l
	}
	orig.interfaces = make(intfList, 0, len(l)-1)
	for _, intf2 := range l {
		if intf2 != intf {
			orig.interfaces.push(intf2)
		}
	}

	if orig.managed != "" {
		for _, intf2 := range intf.hardware.interfaces {
			if intf2 != intf && intf2.ipType != tunnelIP {
				c.err("Crypto %s must not share hardware with other %s",
					intf, intf2)
				break
			}
		}
	}
}

// Link tunnel networks with tunnel hubs.
func (c *spoc) linkTunnels() {
	// Sorting needed for deterministic error messages.
	l := maps.Values(c.symTable.crypto)
	sort.Slice(l, func(i, j int) bool {
		return l[i].name < l[j].name
	})
	for _, cr := range l {
		realHub := cr.hub
		if realHub == nil {
			c.warn("No hub has been defined for %s", cr.name)
			continue
		}
		tunnels := cr.tunnels
		if len(tunnels) == 0 {
			c.warn("No spokes have been defined for %s", cr.name)
		}

		isakmp := cr.ipsec.isakmp
		needId := isakmp.authentication == "rsasig"

		// Note: Crypto router is split internally into two nodes.
		// Typically we get get a node with only a single crypto interface.
		// Take original router with cleartext interface(s).
		r := realHub.router
		if orig := r.origRouter; orig != nil {
			r = orig
		}
		model := r.model
		rName := r.name[len("router:"):]

		// Router of type 'doAuth' can only check certificates,
		// not pre-shared keys.
		if model.doAuth && !needId {
			c.err("%s needs authentication=rsasig in %s", r, isakmp.name)
		}

		if model.crypto == "EZVPN" {
			c.err("Must not use %s of model '%s' as crypto hub", r, model.name)
		}

		// Generate a single tunnel from each spoke to single hub.
		for _, spokeNet := range tunnels {
			netName := spokeNet.name[len("network:"):]
			spoke := spokeNet.interfaces[0]
			realSpoke := spoke.realIntf

			hw := realHub.hardware
			hub := new(routerIntf)
			hub.name = "interface:" + rName + "." + netName
			hub.ipType = tunnelIP
			// Attention: shared hardware between router and origRouter.
			hub.hardware = hw
			hub.isHub = true
			hub.realIntf = realHub
			hub.router = r
			hub.network = spokeNet
			hub.bindNat = cr.bindNat
			hub.routing = realHub.routing
			hub.peer = spoke
			spoke.peer = hub
			r.interfaces.push(hub)
			hw.interfaces.push(hub)
			spokeNet.interfaces.push(hub)

			// We need hub also be available in origIntfs.
			if r.origIntfs != nil {
				r.origIntfs.push(hub)
			}

			if !realSpoke.ip.IsValid() {
				if !(model.doAuth || model.canDynCrypto) {
					c.err(
						"%s can't establish crypto tunnel to %s with unknown IP",
						r, realSpoke)
				}
			}
		}
	}
}

// Collect groups of virtual interfaces
// - be connected to the same network and
// - having the same IP address.
// Link all virtual interfaces to the group of member interfaces.
// Check consistency:
// - Member interfaces must use identical protocol and identical ID.
// - The same ID must not be used by some other group
//   - connected to the same network
//   - emploing the same redundancy type
func (c *spoc) linkVirtualInterfaces() {
	process := func(n *network) {
		// Collect virtual interfaces with same IP in current network.
		ip2virtual := make(map[netip.Addr]intfList)

		// Look up virtual interface of a group inside the same network and
		// using the same ID and type.
		type key2 struct {
			id  string
			typ *mcastProto
		}
		idType2virtual := make(map[key2]*routerIntf)
		for _, v1 := range n.interfaces {
			if !v1.redundant {
				continue
			}
			ip := v1.ip
			t1 := v1.redundancyType
			id1 := v1.redundancyId
			l := ip2virtual[ip]
			if l != nil {
				v2 := l[0]
				t2 := v2.redundancyType
				if t1 != t2 {
					c.err("Must use identical redundancy protocol at\n"+
						" - %s\n"+
						" - %s", v2, v1)
				}
				id2 := v2.redundancyId
				if id1 != id2 {
					c.err("Must use identical ID at\n"+
						" - %s\n"+
						" - %s", v2, v1)
				}
			} else if id1 != "" {
				// Check for identical ID used at unrelated virtual
				// interfaces inside current network.
				k2 := key2{id1, t1}
				if v2 := idType2virtual[k2]; v2 != nil {
					c.err("Must use different ID at unrelated\n"+
						" - %s\n"+
						" - %s", v2, v1)
				} else {
					idType2virtual[k2] = v1
				}
			}
			l.push(v1)
			ip2virtual[ip] = l
		}
		for _, l := range ip2virtual {
			for _, intf := range l {
				intf.redundancyIntfs = l
			}
		}

		// Automatically add pathrestriction to each group of virtual
		// interfaces, where at least one interface is managed.
		// Pathrestriction would be useless if all devices are unmanaged.
		for _, l := range ip2virtual {
			if len(l) < 2 {
				continue
			}
			for _, intf := range l {
				r := intf.router
				if r.managed != "" || r.routingOnly {
					name := "auto-virtual:" + intf.ip.String()
					c.addPathrestriction(name, l)
					break
				}
			}
		}
	}
	for _, n := range c.symTable.network {
		process(n)
	}
}

func (c *spoc) addPathrestriction(name string, l intfList) {
	pr := new(pathRestriction)
	pr.name = name
	pr.elements = l
	c.pathrestrictions = append(c.pathrestrictions, pr)
	for _, intf := range l {
		// Unmanaged router with pathrestriction is handled specially.
		// It is separating zones, but gets no code.
		if intf.router.managed == "" {
			intf.router.semiManaged = true
			// Change to non nil value, so we can detect pathrestricted interfaces
			// during splitSemiManagedRouters.
			// Real value is added later.
			intf.pathRestrict = []*pathRestriction{}
		}
	}
}
