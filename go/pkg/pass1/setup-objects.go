package pass1

import (
	"bytes"
	"cmp"
	"fmt"
	"maps"
	"net/netip"
	"path"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/hknutzen/Netspoc/go/pkg/ast"
	"github.com/hknutzen/Netspoc/go/pkg/filetree"
	"github.com/hknutzen/Netspoc/go/pkg/jcode"
	"github.com/hknutzen/Netspoc/go/pkg/parser"

	"go4.org/netipx"
)

func (c *spoc) readNetspoc(path string) {
	toplevel := c.parseFiles(path)
	c.setupTopology(toplevel)
}

func (c *spoc) showReadStatistics() {
	symTable := c.symTable
	r := len(symTable.router)
	n := len(symTable.network)
	h := len(symTable.host)
	s := len(symTable.service)
	c.info("Read: %d routers, %d networks, %d hosts, %d services", r, n, h, s)
}

func (c *spoc) parseFiles(dir string) []ast.Toplevel {
	var result []ast.Toplevel
	err := filetree.Walk(dir, func(input *filetree.Context) error {
		source := []byte(input.Data)
		aF, err := parser.ParseFile(source, input.Path, 0)
		if err != nil {
			return err
		}
		if errType := c.conf.CheckEmptyFiles; errType != "" {
			if len(aF.Nodes) == 0 && input.Path != path.Join(dir, "POLICY") {
				if !bytes.HasPrefix(source, []byte("# Generated by")) {
					c.warnOrErr(errType, "Ignoring file '%s' without any content",
						input.Path)
				}
			}
		}
		result = append(result, aF.Nodes...)
		return nil
	})
	if err != nil {
		c.abort("%v", err)
	}
	return result
}

func (c *spoc) setupTopology(toplevel []ast.Toplevel) {
	c.checkDuplicate(toplevel)
	c.symTable = createSymbolTable()
	c.initStdProtocols()
	c.setupObjects(toplevel)
	c.setAscendingServices()
	c.checkGeneralPermit()
	c.stopOnErr()
	c.linkTunnels()
	c.linkVirtualInterfaces()
	c.splitSemiManagedRouters()
	c.collectRoutersAndNetworks()
	c.stopOnErr()
}

type symbolTable struct {
	// Leaf nodes, referencing nothing.
	isakmp map[string]*isakmp
	owner  map[string]*owner
	// Named protocols
	protocol map[string]*proto
	// Unnamed protocols like "tcp 80"
	unnamedProto map[string]*proto
	// References protocolgroup, protocol
	protocolgroup map[string]*protoGroup
	// References network, owner
	network   map[string]*network
	aggregate map[string]*network
	// References owner
	host map[string]*host
	// References host, owner, router, protocolgroup, protocol
	router map[string]*router
	// References network, owner, crypto, routerIntf(via crypto)
	routerIntf map[string]*routerIntf
	// References interface, group+, owner
	area map[string]*area
	// References group+, protocolgroup+, owner, service
	service map[string]*service
	// References host, network, interface, area, aggregate, group
	group map[string]*objGroup
	// References isakmp
	ipsec map[string]*ipsec
	// References ipsec
	crypto map[string]*crypto
	// Log tags of routers
	knownLog map[string]bool
}

func createSymbolTable() *symbolTable {
	s := new(symbolTable)
	s.network = make(map[string]*network)
	s.host = make(map[string]*host)
	s.router = make(map[string]*router)
	s.routerIntf = make(map[string]*routerIntf)
	s.area = make(map[string]*area)
	s.service = make(map[string]*service)
	s.protocol = make(map[string]*proto)
	s.unnamedProto = make(map[string]*proto)
	s.protocolgroup = make(map[string]*protoGroup)
	s.group = make(map[string]*objGroup)
	s.aggregate = make(map[string]*network)
	s.owner = make(map[string]*owner)
	s.crypto = make(map[string]*crypto)
	s.ipsec = make(map[string]*ipsec)
	s.isakmp = make(map[string]*isakmp)
	s.knownLog = make(map[string]bool)

	return s
}

func (c *spoc) setupObjects(l []ast.Toplevel) {
	s := c.symTable
	var ipsec []*ast.TopStruct
	var crypto []*ast.TopStruct
	var networks []*ast.Network
	var aggregates []*ast.TopStruct
	var routers []*ast.Router
	var areas []*ast.Area
	var pathrestrictions []*ast.TopList
	var services []*ast.Service
	for _, a := range l {
		typ, name := splitTypedName(a.GetName())
		switch a.(type) {
		case *ast.Network, *ast.Router:
		default:
			if !isSimpleName(name) {
				c.err("Invalid identifier in definition of '%s:%s'", typ, name)
			}
		}
		switch x := a.(type) {
		case *ast.Protocol:
			c.setupProtocol(x)
		case *ast.Protocolgroup:
			l := make(stringList, 0, len(x.ValueList))
			for _, v := range x.ValueList {
				l.push(v.Value)
			}
			s.protocolgroup[name] = &protoGroup{name: a.GetName(), list: l}
		case *ast.Network:
			n := new(network)
			n.name = x.Name
			s.network[name] = n
			networks = append(networks, x)
		case *ast.Router:
			r := new(router)
			r.name = x.Name
			s.router[name] = r
			routers = append(routers, x)
		case *ast.Area:
			areas = append(areas, x)
		case *ast.Service:
			s.service[name] = new(service)
			services = append(services, x)
		case *ast.TopStruct:
			switch typ {
			case "owner":
				c.setupOwner(x)
			case "isakmp":
				c.setupIsakmp(x)
			case "ipsec":
				ipsec = append(ipsec, x)
			case "crypto":
				crypto = append(crypto, x)
			case "any":
				aggregates = append(aggregates, x)
			}
		case *ast.TopList:
			switch typ {
			case "group":
				g := &objGroup{name: x.Name, elements: x.Elements}
				s.group[name] = g
			case "pathrestriction":
				pathrestrictions = append(pathrestrictions, x)
			}
		}
	}
	for _, a := range ipsec {
		c.setupIpsec(a)
	}
	for _, a := range crypto {
		c.setupCrypto(a)
	}
	for _, a := range networks {
		c.setupNetwork46(a)
	}
	for _, a := range aggregates {
		c.setupAggregate(a)
	}
	for _, a := range routers {
		c.setupRouter46(a)
	}
	for _, a := range areas {
		c.setupArea(a)
	}
	for _, a := range pathrestrictions {
		c.setupPathrestriction(a)
	}
	for _, a := range services {
		c.setupService(a)
	}
}

var netV4Attr = []string{"ip", "unnumbered"}
var hostV4Attr = []string{"ip", "range"}

// Clone network and hosts having both ip and ip6 attributes.
func (c *spoc) setupNetwork46(a *ast.Network) {
	netName := strings.TrimPrefix(a.Name, "network:")
	n := c.symTable.network[netName]
	c.setupNetwork1(a, n)
	var hosts4, hosts6 []*host
	for _, ah := range a.Hosts {
		ha4, ha6 := c.getAttr46(a.Name, ah.ComplexValue, hostV4Attr)
		h := c.setupHost1(ah, n)
		if ha4 != nil && ha6 != nil {
			cp := *h
			h6 := &cp
			h6.ipV6 = true
			c.setupHost2(h, ha4)
			hosts4 = append(hosts4, h)
			c.setupHost2(h6, ha6)
			hosts6 = append(hosts6, h6)
		} else if ha6 != nil {
			h.ipV6 = true
			c.setupHost2(h, ha6)
			hosts6 = append(hosts6, h)
		} else {
			c.setupHost2(h, ha4)
			hosts4 = append(hosts4, h)
		}
	}
	na4, na6 := c.getAttr46(a.Name, a.Attributes, netV4Attr)
	c.checkUnnumbered(a, na4, na6)
	needV4 := na4 != nil || hosts4 != nil
	needV6 := na6 != nil || hosts6 != nil
	if needV4 && needV6 {
		cp := *n
		n6 := &cp
		n6.ipV6 = true
		n.hosts = hosts4
		n6.hosts = hosts6
		n.combined46 = n6
		n6.combined46 = n
		// Attributes 'nat' and 'subnet_of' are applied only to IPv4
		// part in combined v4/v6 network.
		n6.subnetOf = nil
		n6.nat = nil
		c.setupNetwork2(n, na4)
		c.setupNetwork2(n6, na6)
		// Attribute 'has_subnets' is only applied to IPv6 part,
		// if both parts have prefix length 0 (the internet).
		if !(n.ipp.Bits() == 0 && n6.ipp.Bits() == 0) {
			n6.hasSubnets = false
		}
	} else if needV6 {
		n.ipV6 = true
		n.hosts = hosts6
		c.setupNetwork2(n, na6)
	} else {
		n.hosts = hosts4
		c.setupNetwork2(n, na4)
	}
}

func (c *spoc) checkUnnumbered(v *ast.Network, na4, na6 *ast.Attribute) {
	isUnnum := func(a *ast.Attribute) bool {
		return a != nil && strings.HasPrefix(a.Name, "unnumbered")
	}
	if isUnnum(na4) || isUnnum(na6) {
		for _, a := range v.Attributes {
			switch a.Name {
			case "crosslink", "partition", "unnumbered", "unnumbered6":
			default:
				if strings.HasPrefix(a.Name, "nat:") {
					c.err("Unnumbered %s must not have NAT definition", v.Name)
				} else {
					c.err("Unnumbered %s must not have attribute '%s'",
						v.Name, a.Name)
				}
			}
		}
		if len(v.Hosts) != 0 {
			c.err("Unnumbered %s must not have host definition", v.Name)
		}
	}
}

// Clone router having interfaces with both ip and ip6 attributes.
func (c *spoc) setupRouter46(a *ast.Router) {
	rName := strings.TrimPrefix(a.Name, "router:")
	r := c.symTable.router[rName]
	c.setupRouter1(a, r)
	cp := *r
	r6 := &cp
	l3Name := c.getAndCheckLayer3(r, a)
	c.checkDuplAttr(&a.Interfaces, a.Name)
	for _, ai := range a.Interfaces {
		iName := strings.Replace(ai.Name, ":", ":"+rName+".", 1)
		is4, is6 := c.checkIntf46(iName, ai)
		if !is4 && !is6 {
			// Short interface without attributes or
			// bridged interface without IP address.
			// Check connected network to decide if v4 and/or v6 is enabled.
			netName := strings.TrimPrefix(ai.Name, "interface:")
			if net, found := c.symTable.network[netName]; found {
				if net.ipV6 {
					is6 = true
				} else {
					is4 = true
					is6 = net.combined46 != nil
				}
			} else {
				// Invalid: Short interface not connected to any network.
				is4 = true
			}
		}
		if is4 {
			c.setupInterface(ai, r, false, l3Name)
		}
		if is6 {
			c.setupInterface(ai, r6, true, l3Name)
		}
	}
	if r6.interfaces != nil && r.interfaces != nil {
		r.combined46 = r6
		r6.combined46 = r
	}
	if r.interfaces != nil || r6.interfaces == nil {
		r.ipV6 = false
		stripFilterOnly(r, r6.interfaces)
		c.setupRouter2(r)
		c.allRouters.push(r)
	}
	if r6.interfaces != nil {
		if r.interfaces == nil {
			r.interfaces = r6.interfaces
			r6 = r
		}
		r6.ipV6 = true
		stripFilterOnly(r6, r.interfaces)
		c.setupRouter2(r6)
		c.allRouters.push(r6)
	}
}

// Analyze bridged interfaces of router and check
// existence of corresponding layer3 device.
func (c *spoc) getAndCheckLayer3(r *router, a *ast.Router) string {
	var l3Name string
	if r.managed != "" {

		// Search bridge interface having
		// 1. name "interface:network/part" and
		// 2. no IP address.
		var bName string
	BRIDGED:
		for _, a1 := range a.Interfaces {
			other, _, found := strings.Cut(a1.Name, "/")
			if !found {
				continue
			}
			for _, a2 := range a1.ComplexValue {
				switch a2.Name {
				case "ip", "ip6",
					"unnumbered", "unnumbered6", "negotiated", "negotiated6":
					break BRIDGED
				}
			}
			// Remember name of corresponding layer3 interface without "/part".
			// One router must not bridge parts of different networks.
			// This would complicate check for interface without IP address
			// as hop for static routing in checkIPAddr.
			if l3Name != "" {
				if l3Name != other {
					c.err("Must not bridge parts of different networks at %s:\n%s",
						a.Name, stringList{bName, a1.Name}.nameList())
				}
			} else {
				l3Name = other
				bName = a1.Name
			}
		}
	}
	return l3Name
}

func stripFilterOnly(r *router, other []*routerIntf) {
	if other != nil {
		r.filterOnly = slices.DeleteFunc(slices.Clone(r.filterOnly),
			func(ipp netip.Prefix) bool {
				return ipp.Addr().Is6() != r.ipV6
			})
	}
}

func ipvx(v6 bool) string { return cond(v6, "IPv6", "IPv4") }

var intfV4Attr = []string{"ip", "unnumbered", "negotiated"}

func (c *spoc) checkIntf46(name string, ai *ast.Attribute) (bool, bool) {
	a4, a6 := c.getAttr46(name, ai.ComplexValue, intfV4Attr)
	v4, v6 := a4 != nil, a6 != nil
	if v4 && v6 {
		if !strings.HasPrefix(a6.Name, a4.Name) {
			c.err("Missing '%s' in dual stack %s", a4.Name+"6", name)
		} else if a4.Name == "ip" && len(a4.ValueList) != len(a6.ValueList) {
			c.err(
				"Attributes 'ip' and 'ip6' must have same number of values in %s",
				name)
		}
	}
	checkSub := func(as *ast.Attribute) {
		for _, a := range as.ComplexValue {
			switch a.Name {
			case "ip":
				if v6 && !v4 {
					c.err(`Must not use 'ip' in %q of %s`, as.Name, name)
				}
			case "ip6":
				if v4 && !v6 {
					c.err(`Must not use 'ip6' in %q of %s`, as.Name, name)
				}
			}
		}
	}
	for _, a := range ai.ComplexValue {
		if a.Name == "virtual" {
			checkSub(a)
		} else if strings.HasPrefix(a.Name, "secondary:") {
			checkSub(a)
		}
	}
	return v4, v6
}

func (c *spoc) getAttr46(name string, l []*ast.Attribute, v4AttrNames []string,
) (*ast.Attribute, *ast.Attribute) {
	var v4, v6 *ast.Attribute
	for _, a := range l {
		set := func(v **ast.Attribute) {
			if *v != nil && (*v).Name != a.Name {
				c.err("Must not use both, %q and %q in %s", a.Name, (*v).Name, name)
				return
			}
			*v = a
		}
		if isAttr6(a) {
			set(&v6)
		} else if slices.Contains(v4AttrNames, a.Name) {
			set(&v4)
		}
	}
	return v4, v6
}

func isAttr6(a *ast.Attribute) bool {
	name := a.Name
	return name[len(name)-1] == '6' && !strings.Contains(name, ":")
}

func (c *spoc) setAscendingServices() {
	s := c.symTable
	for _, name := range slices.Sorted(maps.Keys(s.service)) {
		c.ascendingServices = append(c.ascendingServices, s.service[name])
	}
}

func (c *spoc) setupProtocol(a *ast.Protocol) {
	name := a.Name
	v := a.Value
	l := strings.Split(v, ",")
	def := l[0]
	mod := l[1:]
	pSimp, pSrc := c.getSimpleProtocolAndSrcPort(def, name)
	p := *pSimp
	p.name = name
	// Link named protocol with corresponding unnamed protocol.
	p.main = pSimp
	pName := name[len("protocol:"):]
	c.addProtocolModifiers(mod, &p, pSrc)
	c.symTable.protocol[pName] = &p
}

func (c *spoc) getSimpleProtocol(def string, ctx string) *proto {
	p, pSrc := c.getSimpleProtocolAndSrcPort(def, ctx)
	if pSrc != nil {
		c.err("Must not use source port in %s.\n"+
			" Source port is only valid in named protocol", ctx)
	}
	return p
}

// Return protocol and optional protocol representing source port.
func (c *spoc) getSimpleProtocolAndSrcPort(def string, ctx string,
) (*proto, *proto) {
	var srcP *proto

	p := new(proto)
	p.name = def
	proto, details, _ := strings.Cut(def, " ")
	p.proto = proto
	switch proto {
	case "ip":
		if details != "" {
			c.err("Unexpected details after %s", ctx)
		}
	case "tcp", "udp":
		src, dst := c.getSrcDstRange(details, ctx)
		p.ports = dst
		if src != [2]int{1, 65535} {
			cp := *p
			srcP = &cp
			srcP.ports = src
			srcP = c.cacheUnnamedProtocol(srcP)
		}
	case "icmp":
		c.addICMPTypeCode(details, p, false, ctx)
	case "icmpv6":
		c.addICMPTypeCode(details, p, true, ctx)
	case "proto":
		c.addProtoNr(details, p, ctx)
	default:
		if strings.Contains(ctx, " ") {
			c.err("Unknown protocol in %s", ctx)
		} else {
			c.err("Unknown protocol in %s: %s", ctx, proto)
		}
		p.proto = "ip"
	}
	p = c.cacheUnnamedProtocol(p)
	return p, srcP
}

func (c *spoc) getSrcDstRange(details string, ctx string) ([2]int, [2]int) {
	s1, s2, found := strings.Cut(details, ":")
	if !found {
		s1, s2 = "", s1
	}
	return c.getRange(s1, ctx), c.getRange(s2, ctx)
}

func (c *spoc) getRange(s string, ctx string) [2]int {
	if s == "" {
		return [2]int{1, 65535}
	}
	if s1, s2, found := strings.Cut(s, "-"); found {
		n1 := c.getPort(s1, ctx)
		n2 := c.getPort(s2, ctx)
		if n1 > 0 && n2 > 0 && n1 > n2 {
			c.err("Invalid port range in %s", ctx)
		}
		return [2]int{n1, n2}
	}
	n1 := c.getPort(s, ctx)
	return [2]int{n1, n1}
}

func (c *spoc) getPort(s, ctx string) int {
	num, err := strconv.Atoi(s)
	if err != nil {
		c.err("Expected number in %s: %s", ctx, s)
		return 0
	}
	if num <= 0 {
		c.err("Expected port number > 0 in %s", ctx)
		return 0
	} else if num >= 65536 {
		c.err("Expected port number < 65536 in %s", ctx)
	}
	return num
}

func (c *spoc) addICMPTypeCode(details string, p *proto, v6 bool, ctx string) {
	p.icmpType = -1
	p.icmpCode = -1
	if details == "" {
		return
	}
	s1, s2, found := strings.Cut(details, "/")
	typ := c.getNum256(s1, ctx)
	p.icmpType = typ
	if v6 {
		switch typ {
		case 1, 2, 3, 4, 129:
			p.statelessICMP = true
		}
	} else {
		switch typ {
		case 0, 3, 11:
			p.statelessICMP = true
		}
	}
	if found {
		p.icmpCode = c.getNum256(s2, ctx)
	}
}

func (c *spoc) addProtoNr(details string, p *proto, ctx string) {
	switch c.getNum256(details, ctx) {
	case 0:
		c.err("Invalid protocol number '0' in %s", ctx)
	case 4:
		c.err("Must not use 'proto 4', use 'tcp' instead in %s", ctx)
		return
	case 17:
		c.err("Must not use 'proto 17', use 'udp' instead in %s", ctx)
		return
	}
	p.proto = details
}

func (c *spoc) getNum256(s, ctx string) int {
	num, err := strconv.Atoi(s)
	if err != nil {
		if strings.Contains(s, " ") {
			c.err("Expected single number in %s: %s", ctx, s)
		} else {
			c.err("Expected number in %s: %s", ctx, s)
		}
		return -1
	}
	if num >= 256 {
		c.err("Expected number < 256 in %s", ctx)
	}
	return num
}

func (c *spoc) addProtocolModifiers(l []string, p *proto, srcP *proto) {
	if len(l) == 0 && srcP == nil {
		return
	}
	m := new(modifiers)
	for _, s := range l {
		switch s {
		case "reversed":
			m.reversed = true
		case "stateless":
			m.stateless = true
		case "oneway":
			m.oneway = true
		case "src_net":
			m.srcNet = true
		case "dst_net":
			m.dstNet = true
		case "overlaps":
			m.overlaps = true
		case "no_check_supernet_rules":
			m.noCheckSupernetRules = true
		default:
			c.err("Unknown modifier '%s' in %s", s, p.name)
		}
	}
	if srcP != nil {
		m.srcRange = srcP
	}
	p.modifiers = m
}

func (c *spoc) setupOwner(v *ast.TopStruct) {
	name := v.Name
	o := new(owner)
	o.name = name
	oName := name[len("owner:"):]
	c.symTable.owner[oName] = o
	for _, a := range v.Attributes {
		switch a.Name {
		case "admins":
			o.admins = c.getEmailList(a, name)
		case "watchers":
			o.watchers = c.getEmailList(a, name)
		case "show_all":
			o.showAll = c.getFlag(a, name)
			o.showHiddenOwners = true
		case "only_watch":
			o.onlyWatch = c.getFlag(a, name)
		case "hide_from_outer_owners":
			o.hideFromOuterOwners = c.getFlag(a, name)
		case "show_hidden_owners":
			o.showHiddenOwners = c.getFlag(a, name)
		default:
			if c.addAttr(a, &o.attr, name) {
				if o.attr[unknownOwnerAttr] != unsetVal {
					o.attr[unknownOwnerAttr] = unsetVal
					c.warn("Ignoring attribute 'unknown_owner' in %s", name)
				}
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
	c.removeDupl(append(o.admins, o.watchers...), "admins/watchers of "+name)
}

type attrDescr struct {
	values   []string
	mapEmpty string
}

var isakmpAttr = map[string]attrDescr{
	"nat_traversal": {
		values:   []string{"on", "additional", "off"},
		mapEmpty: "off",
	},
	"authentication": {
		values: []string{"preshare", "rsasig"},
	},
	"encryption": {
		values: []string{
			"aes", "aes192", "aes256", "des", "3des",
			"aes-gcm", "aes-gcm-192", "aes-gcm-256",
		},
	},
	"hash": {
		values: []string{"md5", "sha", "sha256", "sha384", "sha512"},
	},
	"ike_version": {
		values: []string{"1", "2"},
	},
	"group": {
		values: []string{"1", "2", "5", "14", "15", "16", "19", "20", "21", "24"},
	},
	"trust_point": {
		mapEmpty: "none",
	},
}

func (c *spoc) setupIsakmp(v *ast.TopStruct) {
	name := v.Name
	is := new(isakmp)
	is.name = name
	isName := name[len("isakmp:"):]
	c.symTable.isakmp[isName] = is
	hasLifetime := false
	ikeVersion := ""
	for _, a := range v.Attributes {
		switch a.Name {
		case "nat_traversal":
			is.natTraversal = c.getAttr(a, isakmpAttr, name)
		case "authentication":
			is.authentication = c.getAttr(a, isakmpAttr, name)
		case "encryption":
			is.encryption = c.getAttr(a, isakmpAttr, name)
		case "hash":
			is.hash = c.getAttr(a, isakmpAttr, name)
		case "ike_version":
			ikeVersion = c.getAttr(a, isakmpAttr, name)
		case "lifetime":
			is.lifetime = c.getTimeVal(a, name)
			hasLifetime = true
		case "group":
			is.group = c.getAttr(a, isakmpAttr, name)
		case "trust_point":
			is.trustPoint = c.getAttr(a, isakmpAttr, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	if ikeVersion == "" {
		is.ikeVersion = 1
	} else {
		is.ikeVersion, _ = strconv.Atoi(ikeVersion)
	}
	if is.authentication == "" {
		c.err("Missing 'authentication' for %s", name)
	}
	if is.encryption == "" {
		c.err("Missing 'encryption' for %s", name)
	}
	if is.hash == "" {
		c.err("Missing 'hash' for %s", name)
	}
	if is.group == "" {
		c.err("Missing 'group' for %s", name)
	}
	if !hasLifetime {
		c.err("Missing 'lifetime' for %s", name)
	}
	c.checkDuplAttr(&v.Attributes, name)
}

func (c *spoc) getAttr(a *ast.Attribute, descr map[string]attrDescr, ctx string,
) string {
	v := c.getSingleValue(a, ctx)
	d := descr[a.Name]
	if l := d.values; l != nil {
		if !slices.Contains(l, v) {
			c.err("Invalid value in '%s' of %s: %s", a.Name, ctx, v)
		}
	}
	if v2 := d.mapEmpty; v2 != "" && v == v2 {
		v = ""
	}
	return v
}

var ipsecAttr = map[string]attrDescr{
	"esp_encryption": {
		values: []string{
			"none", "3des", "aes", "aes192", "aes256", "des",
			"aes-gcm", "aes-gcm-192", "aes-gcm-256",
			"aes-gmac", "aes-gmac-192", "aes-gmac-256",
		},
	},
	"esp_authentication": {
		values: []string{"none", "md5", "sha", "sha256", "sha384", "sha512"},
	},
	"ah": {
		values: []string{"none", "md5", "sha", "sha256", "sha384", "sha512"},
	},
	"pfs_group": {
		values: []string{"1", "2", "5", "14", "15", "16", "19", "20", "21", "24"},
	},
}

func (c *spoc) setupIpsec(v *ast.TopStruct) {
	name := v.Name
	is := new(ipsec)
	is.name = name
	isName := name[len("ipsec:"):]
	c.symTable.ipsec[isName] = is
	for _, a := range v.Attributes {
		switch a.Name {
		case "key_exchange":
			is.isakmp = c.getIsakmpRef(a, name)
		case "esp_encryption":
			is.espEncryption = c.getAttr(a, ipsecAttr, name)
		case "esp_authentication":
			is.espAuthentication = c.getAttr(a, ipsecAttr, name)
		case "ah":
			is.ah = c.getAttr(a, ipsecAttr, name)
		case "pfs_group":
			is.pfsGroup = c.getAttr(a, ipsecAttr, name)
		case "lifetime":
			is.lifetime = c.getTimeKilobytesPair(a, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
	if is.lifetime == nil {
		c.err("Missing 'lifetime' for %s", name)
	}
	if is.isakmp == nil {
		c.err("Missing 'key_exchange' for %s", name)
	}
}

func (c *spoc) setupCrypto(v *ast.TopStruct) {
	name := v.Name
	cr := new(crypto)
	cr.name = name
	crName := name[len("crypto:"):]
	c.symTable.crypto[crName] = cr
	for _, a := range v.Attributes {
		switch a.Name {
		case "nat_out":
			cr.natOutgoing = c.getNATTags(a, "'nat_out' of "+name)
		case "detailed_crypto_acl":
			cr.detailedCryptoAcl = c.getFlag(a, name)
		case "type":
			cr.ipsec = c.getIpsecRef(a, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
	if cr.ipsec == nil {
		c.err("Missing 'type' for %s", name)
	}
}

func (c *spoc) setupNetwork1(v *ast.Network, n *network) {
	name := v.Name
	netName := strings.TrimPrefix(name, "network:")
	n.name = name
	{
		left, right, found := strings.Cut(netName, "/")
		if found {
			n.ipType = bridgedIP
		}
		if !isSimpleName(left) || found && !isSimpleName(right) {
			c.err("Invalid identifier in definition of '%s'", name)
		}
	}
	for _, a := range v.Attributes {
		switch a.Name {
		case "ip", "ip6":
		case "unnumbered", "unnumbered6":
		case "has_subnets":
			n.hasSubnets = c.getFlag(a, name)
		case "crosslink":
			n.crosslink = c.getFlag(a, name)
		case "subnet_of":
			n.subnetOf = c.tryNetworkRef(a, name)
		case "owner":
			n.owner = c.getRealOwnerRef(a, name)
		case "cert_id":
			n.certId = c.getSingleValue(a, name)
		case "ldap_append":
			n.ldapAppend = c.getSingleValue(a, name)
		case "vpn_attributes":
			n.vpnAttributes = c.getVPNAttributes(a, name)
		case "partition":
			n.partition = c.getIdentifier(a, name)
		case "auto_ipv6_hosts":
			n.autoIPv6Hosts = c.getAutoIPv6Hosts(a, name)
		default:
			if c.addAttr(a, &n.attr, name) {
			} else if nat := c.addNetNat(a, n.nat, name); nat != nil {
				n.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
}

func (c *spoc) setupNetwork2(n *network, a *ast.Attribute) {
	name := n.name
	v6 := n.ipV6
	ipGiven := false
	if a != nil {
		switch a.Name {
		case "ip", "ip6":
			n.ipp = c.getIpPrefix(a, name)
			c.checkVxIP(n.ipp.Addr(), v6, a.Name, name)
			ipGiven = true
		case "unnumbered", "unnumbered6":
			c.getFlag(a, name)
			if n.ipType == bridgedIP {
				c.err("Unnumbered %s must not be bridged", name)
			}
			n.ipType = unnumberedIP
		}
	}
	if n.nat != nil && v6 {
		c.err("NAT not supported for IPv6 %s", n)
	}
	for _, h := range n.hosts {
		h.network = n
		if ap := n.ldapAppend; ap != "" {
			if h.ldapId != "" {
				h.ldapId += ap
			}
		}
	}
	if n.ipType == bridgedIP {
		for _, h := range n.hosts {
			if h.ipRange.IsValid() {
				c.err("Bridged %s must not have %s with range (not implemented)",
					name, h.name)
			}
		}
		for _, nat := range n.nat {
			if !nat.identity {
				c.err("Only identity NAT allowed for bridged %s", n)
				break
			}
		}
	} else if n.ipType != unnumberedIP && !ipGiven {
		c.err("Missing IP address for %s", n.vxName())
	} else if ipp := n.ipp; ipp.IsValid() {
		for _, h := range n.hosts {

			// Check compatibility of host IP and network IP/prefix.
			if h.ip.IsValid() {
				if !ipp.Contains(h.ip) {
					c.err("IP of %s doesn't match address of %s", h, name)
				}
			}
			if h.ipRange.IsValid() {
				// Check range.
				if !(ipp.Contains(h.ipRange.From()) &&
					ipp.Contains(h.ipRange.To())) {

					c.err("IP range of %s doesn't match address of %s", h, name)
				}
			}

			// Compatibility of host and network NAT will be checked later,
			// after inherited NAT definitions have been processed.
		}
		if n.hosts != nil && n.crosslink {
			c.err("Crosslink %s must not have host definitions", name)
		}

		// Check NAT definitions.
		for tag, nat := range n.nat {
			if !nat.dynamic {
				if nat.ipp.Bits() != ipp.Bits() {
					c.err("Mask for non dynamic nat:%s must be equal to mask of %s",
						tag, name)
				}
			}
		}

		// Check and mark networks with ID-hosts.
		ldapCount := 0
		idHostsCount := 0
		for _, h := range n.hosts {
			if h.ldapId != "" {
				ldapCount++
				h.id = h.ldapId
			} else if h.id != "" {
				idHostsCount++
			}
		}
		if ldapCount > 0 {

			// If one host has ldap_id, all hosts must have ldap_id.
			if len(n.hosts) != ldapCount {
				c.err("All hosts must have attribute 'ldap_id' in %s", name)
			}
			if n.certId == "" {
				c.err("Missing attribute 'cert_id' at %s having hosts"+
					" with attribute 'ldap_id'", name)
			} else if !isDomain(n.certId) {
				c.err("Domain name expected in attribute 'cert_id' of %s", name)
			}

			// Mark network.
			n.hasIdHosts = true
		} else {
			if n.ldapAppend != "" {
				c.warn("Ignoring 'ldap_append' at %s", name)
			}
			if n.certId != "" {
				n.certId = ""
				c.warn("Ignoring 'cert_id' at %s", name)
			}
			if idHostsCount > 0 {

				// If one host has ID, all hosts must have ID.
				if len(n.hosts) != idHostsCount {
					c.err("All hosts must have ID in %s", name)
				}

				// Mark network.
				n.hasIdHosts = true
			}
		}

		if !n.hasIdHosts && n.vpnAttributes != nil {
			c.warn("Ignoring 'vpn_attributes' at %s", name)
		}
	}
}

func (c *spoc) setupHost1(v *ast.Attribute, n *network) *host {
	name := v.Name
	h := new(host)
	hName := strings.TrimPrefix(name, "host:")
	if id, found := strings.CutPrefix(hName, "id:"); found {
		if !isIdHostname(id) {
			c.err("Invalid name in definition of '%s'", name)
		}
		h.id = id
		nName := strings.TrimPrefix(n.name, "network:")
		name += "." + nName
	} else {
		if !isSimpleName(hName) {
			c.err("Invalid identifier in definition of '%s'", name)
		}
	}
	h.name = name
	for _, a := range c.getComplexValue(v, "") {
		switch a.Name {
		case "ip", "ip6", "range", "range6":
			// Is processed later.
		case "owner":
			h.owner = c.getRealOwnerRef(a, name)
		case "ldap_id":
			h.ldapId = c.getSingleValue(a, name)
		case "vpn_attributes":
			h.vpnAttributes = c.getVPNAttributes(a, name)
		case "auto_ipv6_hosts":
			h.autoIPv6Hosts = c.getAutoIPv6Hosts(a, name)
		default:
			if nat := c.addIPNat(a, h.nat, name); nat != nil {
				h.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	return h
}

func (c *spoc) setupHost2(h *host, a *ast.Attribute) {
	name := h.name
	hName := strings.TrimPrefix(name, "host:")
	v6 := h.ipV6
	ipGiven := a != nil
	if a != nil {
		switch a.Name {
		case "ip", "ip6":
			h.ip = c.getIp(a, name)
			c.checkVxIP(h.ip, v6, a.Name, name)
		case "range", "range6":
			h.ipRange = c.getIpRange(a, name)
			c.checkVxIP(h.ipRange.From(), v6, a.Name, name)
		}
	}
	if !ipGiven {
		c.err("Missing IP address for %s", name)
	}
	if h.nat != nil && v6 {
		c.err("NAT not supported for IPv6 %s", h)
	}
	if h.id != "" {
		if h.ldapId != "" {
			c.warn("Ignoring attribute 'ldap_id' at %s", name)
			h.ldapId = ""
		}
	} else if h.ldapId != "" {
		if !h.ipRange.IsValid() {
			c.err("Attribute 'ldap_Id' must only be used together with"+
				" IP range at %s", name)
		}
	} else if h.vpnAttributes != nil {
		c.warn("Ignoring 'vpn_attributes' at %s", name)
	}
	if h.nat != nil && h.ipRange.IsValid() {
		// Before changing this,
		// add consistency tests in convert_hosts.
		c.err("No NAT supported for %s with 'range'", name)
	}
	if other, found := c.symTable.host[hName]; found {
		other.combined46 = h
		h.combined46 = other
		if other.ipRange.IsValid() && ipGiven || h.ipRange.IsValid() {
			if !slices.Equal(rangeSize(other.ipRange), rangeSize(h.ipRange)) {
				c.err("IPv4 and IPv6 ranges of %s must have equal size", name)
			}
		}
		// Attribute 'nat' is only applied to IPv4 part in
		// combined v4/v6 host.
		h.nat = nil
	} else {
		c.symTable.host[hName] = h
		if h.autoIPv6Hosts != "" && h.ipV6 {
			c.warn("Ignoring attribute 'auto_ipv6_hosts' in IPv6 %s", name)
		}
	}
}

// Get slice of exponents of 2.
// An IPv6 range may have a size of up to 2^128.
// This exceeds the maximum size of integer.
// Hence calculate with exponents of 2.
func rangeSize(rg netipx.IPRange) []int {
	bitLen := rg.From().BitLen()
	var l []int
	for _, p := range rg.Prefixes() {
		ln := bitLen - p.Bits()
		l = append(l, ln)
	}
	slices.Sort(l)
	j := len(l)
	// Calculate with exponents.
	// Examples:
	// 1,2,2,3 -> 1,3,3 -> 1,4
	// 1,1,1,2,3 -> 1,2,2,3 -> 1,3,3 -> 1,4
	for i := 0; i+2 <= j; i++ {
		if l[i] == l[i+1] && !(i+2 < j && l[i+1] == l[i+2]) {
			l[i]++
			copy(l[i+1:], l[i+2:])
			j--
			i--
		}
	}
	l = l[:j]
	return l
}

func (c *spoc) setupAggregate(v *ast.TopStruct) {
	name := v.Name
	ag := new(network)
	ag.name = name
	ag.isAggregate = true
	agName := name[len("any:"):]
	c.symTable.aggregate[agName] = ag
	hasLink := false
	var ipAttr string
	for _, a := range v.Attributes {
		switch a.Name {
		case "ip", "ip6":
			if ipAttr != "" && ipAttr != a.Name {
				c.err("Must not use both, %q and %q in %s", ipAttr, a.Name, name)
			} else {
				ipAttr = a.Name
				ag.ipp = c.getIpPrefix(a, name)
				ag.ipV6 = a.Name == "ip6"
				c.checkVxIP(ag.ipp.Addr(), ag.ipV6, a.Name, name)
			}
		case "link":
			hasLink = true
			ag.link = c.getNetworkRef(a, name)
		case "no_check_supernet_rules":
			ag.noCheckSupernetRules = c.getFlag(a, name)
		case "owner":
			ag.owner = c.getRealOwnerRef(a, name)
		default:
			if c.addAttr(a, &ag.attr, name) {
			} else if nat := c.addNetNat(a, ag.nat, name); nat != nil {
				ag.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
	net := ag.link
	if net == nil {
		if !hasLink {
			c.err("Attribute 'link' must be defined for %s", name)
		}
		return
	}
	// If no ipAttr is given, this case is handled later when
	// processing zones.
	if ipAttr != "" {
		if ag.ipV6 != net.ipV6 {
			c.err("Must not link %s address to %s network in %s",
				ipvx(ag.ipV6), ipvx(ag.link.ipV6), name)
		}
		if ag.ipp.Bits() != 0 {
			for _, a := range v.Attributes {
				switch a.Name {
				case "ip", "ip6", "link", "owner",
					"overlaps", "identical_body", "multi_owner", "has_unenforceable":
					continue
				}
				if !strings.HasPrefix(a.Name, "nat:") {
					c.err("Must not use attribute '%s' if IP is set for %s",
						a.Name, name)
				}
			}
		}
	}
}

func (c *spoc) setupArea(v *ast.Area) {
	name := v.Name
	ar := &area{name: name}
	arName := strings.TrimPrefix(name, "area:")
	c.symTable.area[arName] = ar
	for _, a := range v.Attributes {
		switch a.Name {
		case "anchor":
			ar.anchor = c.getNetworkRef(a, name)
		case "router_attributes":
			ar.routerAttributes = c.getRouterAttributes(a, ar)
		case "owner":
			o := c.tryOwnerRef(a, name)
			if o != nil && o.onlyWatch {
				ar.watchingOwner = o
			} else {
				ar.owner = o
			}
		case "auto_ipv6_hosts":
			ar.autoIPv6Hosts = c.getAutoIPv6Hosts(a, name)
		default:
			if c.addAttr(a, &ar.attr, name) {
			} else if nat := c.addNetNat(a, ar.nat, name); nat != nil {
				ar.nat = nat
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(&v.Attributes, name)
	expand := func(u *ast.NamedUnion, att string) (intfList, intfList) {
		if u == nil {
			return nil, nil
		}
		ctx := "'" + att + "' of " + name
		l := c.expandGroup(u.Elements, ctx, false)
		var v4, v6 intfList
		for _, el := range l {
			intf, ok := el.(*routerIntf)
			if !ok {
				c.err("Unexpected '%s' in %s", el, ctx)
			} else if intf.router.managed == "" {
				c.err("Must not reference unmanaged %s in %s", intf, ctx)
			} else {
				// Reverse swapped main and virtual interface.
				if main := intf.mainIntf; main != nil {
					intf = main
				}
				if intf.ipV6 {
					v6.push(intf)
				} else {
					v4.push(intf)
				}
			}
		}
		return v4, v6
	}
	b4, b6 := expand(v.Border, "border")
	i4, i6 := expand(v.InclusiveBorder, "inclusive_border")
	var ar2 *area
	if n := ar.anchor; n != nil {
		if b4 != nil || b6 != nil || i4 != nil || i6 != nil {
			c.err("Attribute 'anchor' must not be defined together with"+
				" 'border' or 'inclusive_border' for %s", name)
		}
		l := groupObjList{n}
		if n2 := n.combined46; n2 != nil {
			l.push(n2)
		}
		if len(l) >= 1 {
			n := l[0].(*network)
			ar.anchor = n
			ar.ipV6 = n.ipV6
		}
		if len(l) == 2 {
			n2 := l[1].(*network)
			cp := *ar
			cp.anchor = n2
			ar2 = &cp
		}
	} else {
		if b4 == nil && i4 == nil {
			if b6 == nil && i6 == nil {
				c.err("At least one of attributes 'border', 'inclusive_border'"+
					" or 'anchor' must be defined for %s", name)
			}
			ar.ipV6 = true
			ar.border = b6
			ar.inclusiveBorder = i6
		} else {
			ar.border = b4
			ar.inclusiveBorder = i4
			if b6 != nil || i6 != nil {
				cp := *ar
				cp.border = b6
				cp.inclusiveBorder = i6
				ar2 = &cp
			}
		}
	}
	c.ascendingAreas.push(ar)
	if p := ar.routerAttributes.policyDistributionPoint; p != nil {
		if p.ipV6 != ar.ipV6 {
			if ar2 == nil {
				ar.routerAttributes.policyDistributionPoint = nil
				c.warn("Ignoring %s 'policy_distribution_point' at %s %s",
					ipvx(p.ipV6), ipvx(ar.ipV6), ar)
			}
		} else if ar2 != nil {
			ar2.routerAttributes.policyDistributionPoint = nil
		}
	}
	if ar.nat != nil && ar.ipV6 {
		c.err("NAT not supported for IPv6 %s", ar)
	}
	if ar2 != nil {
		ar.combined46 = ar2
		ar2.combined46 = ar
		ar2.ipV6 = true
		// Attribute 'nat' is only applied to IPv4 part in
		// combined v4/v6 area.
		ar2.nat = nil
		c.ascendingAreas.push(ar2)
	}
}

func (c *spoc) setupPathrestriction(v *ast.TopList) {
	name := v.Name
	l := c.expandGroup(v.Elements, name, false)
	var v4, v6 intfList
	var hasCombined46 bool
	for _, obj := range l {
		intf, ok := obj.(*routerIntf)
		if !ok {
			c.err("%s must not reference %s", name, obj)
		} else if intf.mainIntf != nil {
			// Pathrestrictions must not be applied to secondary interfaces
			c.err("%s must not reference secondary %s", name, obj)
		} else {
			if intf.ipV6 {
				v6.push(intf)
			} else {
				v4.push(intf)
				if intf.combined46 != nil {
					hasCombined46 = true
				}
			}
		}
	}
	if !hasCombined46 && len(v4) != 0 && len(v6) != 0 {
		c.warn("%s has IPv4 and IPv6 interfaces, but no combined v4/6 interface",
			name)
	}
	process := func(elements, other intfList, vx string) *pathRestriction {
		// Show warnings only if other list is empty or useless.
		if len(other) < 2 {
			if len(other) != 0 {
				vx = "IPv" + vx + " "
			} else {
				vx = ""
			}
			switch len(elements) {
			case 0:
				c.warn("Ignoring %s%s without elements", vx, name)
			case 1:
				c.warn("Ignoring %s%s with only %s", vx, name, elements[0])
			}
		}
		if len(elements) < 2 {
			return nil
		}
		return c.addPathrestriction(name, elements)
	}
	var p1 *pathRestriction
	if len(v4) != 0 || len(v6) == 0 {
		p1 = process(v4, v6, "4")
	}
	if len(v6) != 0 {
		p2 := process(v6, v4, "6")
		if p1 != nil && p2 != nil {
			p1.combined46 = p2
			p2.combined46 = p1
		}
	}
}

func (c *spoc) setupRouter1(v *ast.Router, r *router) {
	name := v.Name
	rName := strings.TrimPrefix(name, "router:")
	{
		left, right, found := strings.Cut(rName, "@")
		if found {
			r.deviceName = left
			r.vrf = right
		} else {
			r.deviceName = rName
		}
		if !isSimpleName(left) || found && !isSimpleName(right) {
			c.err("Invalid identifier in definition of '%s'", name)
		}
	}
	noProtectSelf := false
	for _, a := range v.Attributes {
		switch a.Name {
		case "managed":
			r.managed = c.getManaged(a, name)
		case "filter_only":
			r.filterOnly = c.getIpPrefixList(a, name)
		case "merge_tunnelspecified":
			r.mergeTunnelSpecified = c.getIpPrefixList(a, name)
		case "model":
			r.model = c.getModel(a, name)
		case "no_group_code":
			r.noGroupCode = c.getFlag(a, name)
		case "no_protect_self":
			noProtectSelf = c.getFlag(a, name)
		case "log_default":
			r.logDefault = c.getLogModifiers(a, name)
		case "log_deny":
			r.logDeny = c.getLogModifiers(a, name)
		case "routing":
			r.routingDefault = c.getRouting(a, name)
		case "owner":
			r.owner = c.getRealOwnerRef(a, name)
		case "vpn_attributes":
			r.vpnAttributes = c.getVPNAttributes(a, name)
		case "policy_distribution_point":
			r.policyDistributionPoint = c.tryHostRef(a, name)
		case "general_permit":
			r.generalPermit = c.getGeneralPermit(a, name)
		case "management_instance":
			r.managementInstance = c.getFlag(a, name)
		case "backup_of":
			r.backupOf = c.tryRouterRef(a, name)
		default:
			if !c.addLog(a, r) {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}
	c.checkDuplAttr(&v.Attributes, name)

	if managed := r.managed; managed != "" {
		if r.model == nil {
			c.err("Missing 'model' for managed %s", name)

			// Prevent further errors.
			r.model = &model{name: "unknown"}
		}

		// Router is semiManaged if only routes are generated.
		if managed == "routing_only" {
			r.semiManaged = true
			r.routingOnly = true
			r.managed = ""
		}

		if r.vrf != "" && !r.model.canVRF {
			c.err("Must not use VRF at %s of model %s", name, r.model.class)
		}
		if r.vrf == "" && r.model.needVRF {
			c.err("Must use VRF ('@...' in name) at %s of model %s",
				name, r.model.class)
		}
	} else if r.owner != nil {
		// Unmanaged device.
		c.warn("Ignoring attribute 'owner' at unmanaged %s", name)
	}

	// Check again after "managed=routing_only" has been removed.
	if managed := r.managed; managed != "" {
		if managed == "local" {
			if r.model.hasIoACL {
				c.err("Must not use 'managed = local' at %s of model %s",
					name, r.model.name)
			}
		} else if r.filterOnly != nil {
			c.warn(
				"Ignoring attribute 'filter_only' at %s;"+
					" only valid with 'managed = local'", name)
			r.filterOnly = nil
		}
		for name, modList := range r.log {
			c.symTable.knownLog[name] = true
			r.log[name] = c.transformLog("log:"+name, modList, r)
		}
		if modList := r.logDefault; modList != "" {
			r.logDefault = c.transformLog("log_default", modList, r)
		}
		if modList := r.logDeny; modList != "" {
			r.logDeny = c.transformLog("log_deny", modList, r)
		}

		if noProtectSelf && !r.model.needProtect {
			c.err("Must not use attribute 'no_protect_self' at %s of model %s",
				name, r.model.name)
		}
		if r.model.needProtect {
			r.needProtect = !noProtectSelf
		}

		if !r.model.doAuth {
			if r.vpnAttributes != nil {
				c.warn("Ignoring 'vpn_attributes' at %s", name)
			}
			if r.mergeTunnelSpecified != nil {
				c.warn("Ignoring 'merge_tunnelspecified' at %s", name)
			}
		}
	}

	if r.managementInstance {
		if r.managed != "" || r.routingOnly {
			c.warn("Ignoring attribute 'management_instance' at managed %s",
				name)
		} else if r.model == nil {
			c.warn("Ignoring attribute 'management_instance' at %s"+
				" without model",
				name)
		} else if !r.model.needManagementInstance {
			c.warn("Ignoring attribute 'management_instance' at %s of model %s",
				name, r.model.name)
		} else {
			// This simplifies inheritance of policy_distribution_point
			// from area to management_instance.
			r.semiManaged = true
		}
		if r.vrf != "" {
			c.err("%s with attribute 'management_instance' must not use VRF", name)
		}
		if r2 := r.backupOf; r2 != nil {
			// r2.deviceName is set, if r2 already has been parsed.
			if r2.deviceName != "" && !r2.managementInstance {
				c.warn("Ignoring attribute 'backup_of' at %s,\n"+
					" because %s hasn't attribute 'management_instance'",
					name, r2.name)
			} else if r3 := r2.backupInstance; r3 != nil {
				c.warn("Ignoring attribute 'backup_of' at %s,\n"+
					" because %s is already 'backup_of' %s",
					name, r3.name, r2.name)
			} else {
				r2.backupInstance = r
			}
		}
	} else {
		if r.backupOf != nil {
			c.warn("Ignoring attribute 'backup_of' at %s"+
				" without attribute 'management_instance'",
				name)
		}
		// Attribute .backupInstance has been set before r was parsed.
		if r2 := r.backupInstance; r2 != nil {
			c.warn("Ignoring attribute 'backup_of' at %s,\n"+
				" because %s hasn't attribute 'management_instance'",
				r2.name, name)
		}
		if r.policyDistributionPoint != nil &&
			r.model != nil && r.model.needManagementInstance {

			c.warn("Ignoring attribute 'policy_distribution_point' at %s\n"+
				" Add this attribute at 'management_instance' instead",
				name)
		}
	}
}

func (c *spoc) setupRouter2(r *router) {
	// Link interface with router, after dual stack router has been split.
	for _, intf := range withSecondary(r.interfaces) {
		intf.router = r
	}

	if p := r.policyDistributionPoint; p != nil {
		if p.ipV6 != r.ipV6 {
			r.policyDistributionPoint = nil
			if !r.isCombined46() {
				c.warn("Ignoring %s 'policy_distribution_point' at %s %s",
					ipvx(p.ipV6), ipvx(r.ipV6), r)
			}
		}
	}

	// Create objects representing hardware interfaces.
	// All logical interfaces using the same hardware are linked
	// to the same hardware object.
	if r.managed != "" || r.routingOnly {
		hwMap := make(map[string]*hardware)
		for _, intf := range r.interfaces {
			hw := intf.hardware
			if same, found := hwMap[hw.name]; found {
				// Hardware keeps attribute .loopback only if all
				// interfaces have attribute .loopback.
				if !intf.loopback {
					same.loopback = false
				}
				intf.hardware = same
				hw = same
			} else {
				hwMap[hw.name] = hw
				r.hardware = append(r.hardware, hw)
			}
			// Remember, which logical interfaces are bound
			// to which hardware.
			hw.interfaces.push(intf)
			for _, s := range intf.secondaryIntfs {
				s.hardware = hw
			}
		}
		for _, hw := range hwMap {
			l := hw.interfaces
			if r.model.noSharedHardware && len(l) > 1 {
				c.err("Different interfaces must not share same hardware '%s'"+
					" at %s of model %s", hw.name, r.vxName(), r.model.class)
			}

			// All logical interfaces of one hardware interface need to
			// use the same NAT binding, because NAT operates on
			// hardware, not on logic.
			intf := l[0]
			for _, other := range l[1:] {
				if !slices.Equal(intf.natOutgoing, other.natOutgoing) {
					c.err("%s and %s using identical 'hardware = %s'\n"+
						" must also use identical NAT binding", intf, other, hw.name)
				}
			}
		}
		if r.model.filter == "NSX" {
			if len(hwMap) != 2 || hwMap["IN"] == nil || hwMap["OUT"] == nil {
				c.err("%s of model %s must have exactly 2 interfaces"+
					" with hardware IN and OUT", r.vxName(), r.model.class)
			}
			if r.model.tier == "" {
				c.err("Must add extension 'T0' or 'T1' at %s of model %s",
					r, r.model.class)
			}
		}
	}

	if r.managed != "" {
		if r.managed == "local" && r.filterOnly == nil {
			c.err("Missing attribute 'filter_only' for %s", r)
		}

		for _, intf := range withSecondary(r.interfaces) {
			// Inherit attribute 'routing' to interfaces.
			if r.routingDefault != nil {
				if intf.routing == nil {
					if intf.ipType == bridgedIP {
						c.err("Attribute 'routing' not supported for bridge %s",
							r.name)
					} else if !intf.loopback {
						intf.routing = r.routingDefault
					}
				}
			}
			if rt := intf.routing; rt != nil && intf.ipType == unnumberedIP {
				switch rt.name {
				case "manual", "dynamic":
				default:
					c.err("Routing '%s' not supported for unnumbered %s",
						rt.name, intf)
				}
			}
		}

		isCryptoHub := false
		var layer3Intf *routerIntf
		for _, intf := range r.interfaces {
			if intf.hub != nil || intf.spoke != nil {
				if r.model.crypto == "" {
					c.err("Crypto not supported for %s of model %s",
						r.name, r.model.name)
				}
			}
			if intf.hub != nil {
				isCryptoHub = true
			}
			// Link bridged interfaces with corresponding layer3 device.
			// Used in findAutoInterfaces.
			if intf.ipType == bridgedIP {
				if layer3Intf == nil {
					i := slices.IndexFunc(r.interfaces, func(intf *routerIntf) bool {
						return intf.isLayer3
					})
					if i == -1 {
						l3Name, _, _ := strings.Cut(intf.vxName(), "/")
						c.err("Must define %s for corresponding bridge interfaces",
							l3Name)
						// Prevent further errors.
						layer3Intf = intf
					} else {
						layer3Intf = r.interfaces[i]
					}
				}
				intf.layer3Intf = layer3Intf
			}
		}
		if r.model.doAuth {
			if !isCryptoHub {
				c.warn("Attribute 'hub' needs to be defined"+
					" at some interface of %s of model %s", r.name, r.model.name)
			}
		}

		c.checkNoInAcl(r)
	}

	if r.managementInstance {
		if len(r.interfaces) != 1 {
			c.err("%s with attribute 'management_instance' needs"+
				" exactly one interface", r.name)
		} else if r.interfaces[0].ipType != hasIP {
			c.err("%s with attribute 'management_instance' needs"+
				" interface with IP address", r.name)
		}
	}

	if r.managed != "" || r.routingOnly {
		// Unmanaged router is handled in splitSemiManagedRouters.
		c.moveNatIn2Out(r)
	}
	var otherSpoke *routerIntf
	rName := strings.TrimPrefix(r.name, "router:")
	for _, intf := range r.interfaces {
		if cr := intf.spoke; cr != nil {
			if otherSpoke != nil {
				c.err("Must not define crypto spoke at more than one interface:\n"+
					" - %s\n"+
					" - %s", otherSpoke, intf)
				continue
			}
			otherSpoke = intf
			// Create tunnel network.
			netName := "tunnel:" + rName
			tNet := new(network)
			tNet.name = "network:" + netName
			tNet.ipType = tunnelIP
			tNet.ipV6 = r.ipV6

			// Tunnel network will later be attached to crypto hub.
			cr.tunnels.push(tNet)

			// Create tunnel interface.
			iName := rName + "." + netName
			tIntf := new(routerIntf)
			tIntf.name = "interface:" + iName
			tIntf.ipType = tunnelIP
			tIntf.ipV6 = r.ipV6
			tIntf.router = r
			tIntf.network = tNet
			tIntf.realIntf = intf
			tIntf.routing = intf.routing
			tIntf.natOutgoing = intf.natOutgoing
			intf.natOutgoing = nil
			tIntf.natIncoming = intf.natIncoming
			intf.natIncoming = nil
			tIntf.id = intf.id
			if r.managed != "" {
				hw := intf.hardware
				tIntf.hardware = hw
				hw.interfaces.push(tIntf)
			}
			r.interfaces.push(tIntf)
			tNet.interfaces.push(tIntf)
		}
		if (intf.spoke != nil || intf.hub != nil) && !intf.noCheck {
			c.moveLockedIntf(intf)
		}
	}
}

// moveNatIn2Out moves NAT tags of attribute natIncoming to
// attribute natOutgoing of other interfaces of the same router.
func (c *spoc) moveNatIn2Out(r *router) {
	added := make(map[string]bool)
	for _, intf := range r.interfaces {
		for _, t := range intf.natIncoming {
			if slices.Contains(intf.natOutgoing, t) {
				c.err(
					"Must not use NAT tag %q at both 'nat_in' and 'nat_out' of %s",
					t, intf)
			}
			if added[t] {
				continue
			}
			added[t] = false
			for _, other := range intf.router.interfaces {
				if other == intf || slices.Contains(other.natIncoming, t) {
					continue
				}
				if other.hub != nil {
					c.err("Must not apply NAT tag %q (from 'nat_in')"+
						" to crypto hub %s\n"+
						" Move it as 'nat_out' to crypto definition instead",
						t, other)
				} else if slices.Contains(other.natOutgoing, t) {
					c.err(
						"Must not use NAT tag %q at both\n"+
							" - 'nat_in' of %s and\n"+
							" - 'nat_out' of %s", t, intf, other)
				} else {
					other.natOutgoing = append(other.natOutgoing, t)
					slices.Sort(other.natOutgoing)
				}
				added[t] = true
			}
		}
	}
	for t, seen := range added {
		if !seen {
			c.warn(
				"Ignoring 'nat_in = %s' without effect,"+
					" applied at every interface of %s", t, r)
		}
	}
}

func withSecondary(l intfList) intfList {
	result := l
	for _, intf := range l {
		result = append(result, intf.secondaryIntfs...)
	}
	return result
}

func takeAttr46(a *ast.Attribute, v6 bool) bool {
	return v6 == isAttr6(a)
}

func (c *spoc) setupInterface(
	v *ast.Attribute, r *router, v6 bool, l3Name string,
) {
	rName := strings.TrimPrefix(r.name, "router:")
	nName := strings.TrimPrefix(v.Name, "interface:")
	iName := rName + "." + nName
	name := "interface:" + iName
	intf := new(routerIntf)
	intf.name = name
	var l []*ast.Attribute

	// Allow short form of interface definition.
	if !emptyAttr(v) {
		l = c.getComplexValue(v, r.name)
	}

	var secondaryList intfList
	var virtual *routerIntf
	var vip bool
	var hwName string
	var subnetOf *network
	var nat natTagMap
	ipGiven := false
	for _, a := range l {
		switch a.Name {
		case "ip", "ip6":
			if !takeAttr46(a, v6) {
				break
			}
			ipGiven = true
			if ipList := c.getIpList(a, name); ipList != nil {
				intf.ip = ipList[0]
				c.checkVxIP(intf.ip, v6, a.Name, name)

				// Build interface objects for secondary IP addresses.
				// These objects are named interface:router.name.2, ...
				counter := 2
				for _, ip := range ipList[1:] {
					suffix := "." + strconv.Itoa(counter)
					name := name + suffix
					intf := new(routerIntf)
					intf.name = name
					intf.ip = ip
					secondaryList.push(intf)
					c.checkVxIP(ip, v6, a.Name, name)
					counter++
				}
			}
		case "hardware":
			hwName = c.getSingleValue(a, name)
		case "owner":
			intf.owner = c.getRealOwnerRef(a, name)
		case "unnumbered", "unnumbered6":
			if takeAttr46(a, v6) {
				c.getFlag(a, name)
				intf.ipType = unnumberedIP
			}
		case "negotiated", "negotiated6":
			if takeAttr46(a, v6) {
				c.getFlag(a, name)
				intf.ipType = negotiatedIP
			}
		case "loopback":
			intf.loopback = c.getFlag(a, name)
		case "vip":
			vip = c.getFlag(a, name)
		case "no_in_acl":
			intf.noInAcl = c.getFlag(a, name)
		case "dhcp_server":
			intf.dhcpServer = c.getFlag(a, name)
		case "dhcp_client":
			intf.dhcpClient = c.getFlag(a, name)
		case "subnet_of":
			subnetOf = c.tryNetworkRef(a, name)
		case "hub":
			intf.hub = c.getCryptoRefList(a, name)
		case "spoke":
			intf.spoke = c.getCryptoRef(a, name)
		case "id":
			intf.id = c.getSingleValue(a, name)
		case "virtual":
			virtual = c.getVirtual(a, v6, name)
		case "nat_out":
			intf.natOutgoing = c.getNATTags(a, "'nat_out' of "+name)
		case "nat_in":
			intf.natIncoming = c.getNATTags(a, "'nat_in' of "+name)
		case "routing":
			intf.routing = c.getRouting(a, name)
		case "reroute_permit":
			intf.reroutePermit = c.tryNetworkRefList(a, name)
		case "no_check":
			intf.noCheck = c.getFlag(a, name)
		default:
			if m := c.addIntfNat(a, nat, name); m != nil {
				nat = m
			} else if name2, fnd := strings.CutPrefix(a.Name, "secondary:"); fnd {
				intf := new(routerIntf)
				intf.name = name + "." + name2
				sCtx := a.Name + " of " + name
				l := c.getComplexValue(a, name)
				for _, a2 := range l {
					switch a2.Name {
					case "ip", "ip6":
						if takeAttr46(a2, v6) {
							intf.ip = c.getIp(a2, sCtx)
						}
					default:
						c.err("Unexpected attribute in %s: %s", sCtx, a2.Name)
					}
				}
				if !intf.ip.IsValid() {
					c.err("Missing '%s' in %s", v6Attr("ip", v6), sCtx)
					intf.ipType = shortIP
				}
				secondaryList.push(intf)
			} else {
				c.err("Unexpected attribute in %s: %s", name, a.Name)
			}
		}
	}

	if l3Name == v.Name {
		intf.loopback = true
		intf.isLayer3 = true
		if r.model.class == "ASA" {
			if hwName != "device" {
				c.err(
					"Layer3 %s must use 'hardware' named 'device' for model 'ASA'",
					intf)
			}
		}
		if !ipGiven {
			c.err("Layer3 %s must have IP address", intf)
		}
		if secondaryList != nil || virtual != nil {
			c.err("Layer3 %s must not have secondary or virtual IP", intf)
			secondaryList = nil
			virtual = nil
		}
	}

	// Interface at bridged network
	// - without IP is interface of bridge,
	// - with IP (or unnumbered / negotiated) is interface of router.
	if !ipGiven &&
		intf.ipType != unnumberedIP &&
		intf.ipType != negotiatedIP &&
		strings.Contains(iName, "/") &&
		r.managed != "" {

		intf.ipType = bridgedIP
	}

	// Check spoke before adding virtual interface to secondaryList.
	if intf.spoke != nil {
		if secondaryList != nil {
			c.err("%s with attribute 'spoke' must not have secondary interfaces",
				intf)
			secondaryList = nil
		}
		if intf.hub != nil {
			c.err("%s with attribute 'spoke' must not have attribute 'hub'",
				intf)
		}
	} else if intf.id != "" {
		intf.id = ""
		c.warn("Ignoring attribute 'id' only valid with 'spoke' at %s", intf)
	}

	// Swap virtual interface and main interface
	// or take virtual interface as main interface if no main IP available.
	// Subsequent code becomes simpler if virtual interface is main interface.
	if virtual != nil {
		switch intf.ipType {
		case unnumberedIP:
			c.err("No virtual IP supported for unnumbered %s", name)
		case negotiatedIP:
			c.err("No virtual IP supported for negotiated %s", name)
		case bridgedIP:
			c.err("No virtual IP supported for bridged %s", name)
		default:
			if intf.ip.IsValid() {

				// Move main IP to secondary.
				secondary := new(routerIntf)
				secondary.name = intf.name
				secondary.ip = intf.ip
				secondaryList.push(secondary)

				// But we need the original main interface
				// when handling auto interfaces.
				intf.origMain = secondary
			}
		}
		if nat != nil {
			c.err("%s with virtual interface must not use attribute 'nat'",
				name)
		}
		if intf.hub != nil {
			c.err("%s with virtual interface must not use attribute 'hub'",
				name)
		}
		if intf.spoke != nil {
			c.err("%s with virtual interface must not use attribute 'spoke'",
				name)
		}
		intf.name = virtual.name
		intf.ip = virtual.ip
		intf.redundant = virtual.redundant
		intf.redundancyType = virtual.redundancyType
		intf.redundancyId = virtual.redundancyId
	} else if !ipGiven && intf.ipType == hasIP {
		intf.ipType = shortIP
	}
	if nat != nil && !ipGiven {
		c.err("No NAT supported for %s without IP", name)
	}

	typ := ""
	check := func(p bool, a string) {
		if p {
			c.err("Attribute '%s' not supported for %s %s", a, typ, name)
		}
	}
	if intf.ipType == bridgedIP {
		typ = "bridged"
		check(intf.owner != nil, "owner")
		check(intf.loopback, "loopback")
		check(vip, "vip")
		intf.loopback = false
	} else if vip {
		// Attribute 'vip' is an alias for 'loopback'.
		typ = "'vip'"
		intf.loopback = true
	} else if intf.loopback && !intf.isLayer3 {
		typ = "loopback"
	}
	if typ != "" {
		if secondaryList != nil {
			c.err("Secondary or virtual IP not supported for %s %s", typ, name)
			secondaryList = nil
			intf.origMain = nil // From virtual interface
		}

		// Most attributes are invalid for loopback interface.
		check(intf.noInAcl, "no_in_acl")
		check(intf.noCheck, "no_check")
		check(intf.id != "", "id")
		check(intf.hub != nil, "hub")
		check(intf.spoke != nil, "spoke")
		check(intf.dhcpClient, "dhcp_client")
		check(intf.dhcpServer, "dhcp_server")
		check(intf.routing != nil, "routing")
		check(intf.reroutePermit != nil, "reroute_permit")
		switch intf.ipType {
		case unnumberedIP:
			c.err("Attribute '%s' not supported for %s %s",
				v6Attr("unnumbered", v6), typ, name)
		case negotiatedIP:
			c.err("Attribute '%s' not supported for %s %s",
				v6Attr("negotiated", v6), typ, name)
		case shortIP:
			c.err("%s %s must have IP address", typ, name)
		}
	}
	if subnetOf != nil && !intf.loopback {
		c.err("Attribute 'subnet_of' must not be used at %s\n"+
			" It is only valid together with attribute 'loopback'", name)
	}
	if intf.noCheck && (intf.hub == nil || !r.model.doAuth) {
		intf.noCheck = false
		c.warn("Ignoring attribute 'no_check' at %s", intf)
	}
	if secondaryList != nil {
		if intf.ipType != hasIP {
			c.err("%s without IP address must not have secondary address", intf)
			secondaryList = nil
		}
	}
	if r.managed != "" || r.routingOnly {

		// Managed router must not have short interface.
		if intf.ipType == shortIP {
			c.err("Short definition of %s not allowed", name)
		}

		// Interface of managed router needs to have a hardware name.
		if hwName == "" {
			c.err("Missing 'hardware' for %s", name)

			// Prevent further errors.
			hwName = "unknown"
		}
		intf.hardware = &hardware{name: hwName, loopback: intf.loopback}

		// Interface of managed router must not have individual owner,
		// because whole device is managed from one place.
		if intf.owner != nil {
			c.warn("Ignoring attribute 'owner' at managed %s", intf)
			intf.owner = nil
		}

		// Attribute 'vip' only supported at unmanaged router.
		if vip {
			c.err("Must not use attribute 'vip' at %s of managed router", name)
		}

		// Don't allow 'routing=manual' at single interface, because
		// approve would remove manual routes otherwise.
		// Approve only leaves routes unchanged, if Netspoc generates
		// no routes at all.
		if rt := intf.routing; rt != nil && rt.name == "manual" {
			c.warn("'routing=manual' must only be applied to router, not to %s",
				intf)
		}

		if l := intf.hub; l != nil {
			if intf.ipType != hasIP {
				c.err("Crypto hub %s must have IP address", intf)
			}
			if intf.natOutgoing != nil {
				c.err("Must not use 'nat_out' at crypto hub %s\n"+
					" Move it as 'nat_out' to crypto definition instead", intf)
			}
			for _, cr := range l {
				if cr.hub != nil {
					c.err("Must use 'hub = %s' exactly once, not at both\n"+
						" - %s\n"+
						" - %s", cr.name, cr.hub, intf)
				} else {
					cr.hub = intf
				}
			}
		}
	} else { // Unmanaged device.
		if intf.reroutePermit != nil {
			intf.reroutePermit = nil
			c.warn("Ignoring attribute 'reroute_permit' at unmanaged %s", intf)
		}
		if intf.hub != nil {
			c.warn("Ignoring attribute 'hub' at unmanaged %s", intf)
			intf.hub = nil
		}
	}

	intf.secondaryIntfs = secondaryList
	for _, s := range secondaryList {
		s.mainIntf = intf
		s.natOutgoing = intf.natOutgoing
		s.routing = intf.routing
	}

	// Collect interfaces at router.
	r.interfaces.push(intf)
	for _, intf := range append(intfList{intf}, secondaryList...) {
		intf.ipV6 = v6
		name := intf.name
		iName := name[len("interface:"):]
		if other, found := c.symTable.routerIntf[iName]; found {
			if intf.ipV6 == other.ipV6 {
				c.err("Duplicate definition of %s in %s", name, r.vxName())
			}
			other.combined46 = intf
			intf.combined46 = other
			if intf.ipV6 {
				intf.natIncoming = nil
				intf.natOutgoing = nil
				intf.nat = nil
				intf.hub = nil
				intf.spoke = nil
				subnetOf = nil
				continue
			}
		} else if v6 {
			if intf.natIncoming != nil {
				c.warn("Ignoring attribute 'nat_in' at %s", intf.vxName())
				intf.natIncoming = nil
			}
			if intf.natOutgoing != nil {
				c.warn("Ignoring attribute 'nat_out' at %s", intf.vxName())
				intf.natOutgoing = nil
			}
		}
		c.symTable.routerIntf[iName] = intf

		// Check NAT after attributes have been removed from combined
		// IPv6 interface.
		if r.managed == "" {
			if intf.natOutgoing != nil || intf.natIncoming != nil {
				r.semiManaged = true
			}
		}
	}

	// Automatically create a network for loopback interface.
	if intf.loopback {
		if !isSimpleName(nName) {
			c.err("Invalid identifier in '%s' of '%s'", v.Name, r)
		}
		var shortName string
		var fullName string

		// Special handling needed for virtual loopback interfaces.
		// The created network needs to be shared among a group of
		// interfaces.
		if intf.redundant {

			// Shared virtual loopback network gets name
			// 'virtual:netname'. Don't use standard name to prevent
			// network from getting referenced from rules.
			shortName = "virtual:" + nName
			fullName = "network:" + shortName
		} else {

			// Single loopback network needs not to get an unique name.
			// Take an invalid name 'router.loopback' to prevent name
			// clashes with real networks or other loopback networks.
			fullName = intf.name
			shortName = fullName[len("interface:"):]
		}
		if v6 {
			shortName += ":v6"
		}
		var n *network
		if intf.redundant {
			n = c.symTable.network[shortName]
		}
		if n == nil {
			n = new(network)
			n.name = fullName
			n.ipV6 = v6
			n.ipp = netip.PrefixFrom(intf.ip, intf.ip.BitLen())

			// Mark as automatically created.
			n.loopback = true
			n.subnetOf = subnetOf

			// Move NAT definition to loopback network.
			n.nat = nat

			if intf.redundant {
				c.symTable.network[shortName] = n
			}
		}
		intf.network = n
		n.interfaces.push(intf)
	} else {
		// Link interface with network.
		n := c.symTable.network[nName]
		if n == nil {
			c.err("Referencing undefined network:%s from %s", nName, name)
		} else {
			if v6 != n.ipV6 {
				if n.combined46 != nil {
					n = n.combined46
				} else {
					c.err("Must not reference %s %s from %s %s",
						ipvx(n.ipV6), n, ipvx(v6), intf)
					n = nil
				}
			}
			if n != nil {
				n.interfaces.push(intf)
				for _, intf := range append(intfList{intf}, secondaryList...) {
					intf.network = n
					if intf.ipType != shortIP && (!ipGiven || intf.ip.IsValid()) {
						c.checkInterfaceIp(intf, n)
					}
				}
			}
		}

		// Non loopback interface must use simple NAT with single IP
		// and without any NAT attributes.
		if len(nat) != 0 {
			intf.nat = make(map[string]netip.Addr)
			for tag, info := range nat {
				// Reject all non IP NAT attributes.
				// 'hidden' and 'identity' always set 'dynamic'.
				if info.dynamic {
					c.err("Only 'ip' allowed in nat:%s of %s", tag, intf)
				} else {
					intf.nat[tag] = info.ipp.Addr()
				}
			}
		}
	}
}

func v6Attr(attr string, v6 bool) string {
	return cond(v6, attr+"6", attr)
}

func (c *spoc) setupService(v *ast.Service) {
	name := v.Name
	sName := name[len("service:"):]
	sv := c.symTable.service[sName]
	sv.name = name
	if d := v.Description; d != nil {
		sv.description = d.Text
	}
	for _, a := range v.Attributes {
		switch a.Name {
		case "identical_body":
			sv.identicalBody =
				c.tryServiceRefList(a, name)
		case "ipv4_only":
			sv.ipV4Only = c.getFlag(a, name)
		case "ipv6_only":
			sv.ipV6Only = c.getFlag(a, name)
		case "overlaps":
			sv.overlaps = c.tryServiceRefList(a, name)
		case "multi_owner":
			sv.multiOwner = c.getFlag(a, name)
		case "unknown_owner":
			sv.unknownOwner = c.getFlag(a, name)
		case "has_unenforceable":
			sv.hasUnenforceable = c.getFlag(a, name)
		case "disabled":
			sv.disabled = c.getFlag(a, name)
		case "disable_at":
			sv.disableAt = c.getSingleValue(a, name)
			if c.dateIsReached(sv.disableAt, "'disable_at' of "+name) {
				sv.disabled = true
			}
		default:
			c.err("Unexpected attribute in %s: %s", name, a.Name)
		}
	}
	if sv.ipV4Only && sv.ipV6Only {
		c.err("Must not use ipv4_only and ipv6_only together at %s", name)
	}
	sv.foreach = v.Foreach
	sv.user = v.User.Elements
	userUserCount := 0
	for _, v2 := range v.Rules {
		ru := new(unexpRule)
		ru.service = sv
		if v2.Deny {
			ru.action = "deny"
		} else {
			ru.action = "permit"
		}
		ru.src = v2.Src.Elements
		ru.dst = v2.Dst.Elements
		srcUser := c.checkUserInUnion(ru.src, "'src' of "+name)
		dstUser := c.checkUserInUnion(ru.dst, "'dst' of "+name)
		if !(srcUser || dstUser) {
			c.err("Each rule of %s must use keyword 'user'", name)
		}
		if sv.foreach && !(srcUser && dstUser) {
			c.warn(
				"Each rule of %s should reference 'user' in 'src' and 'dst'\n"+
					" because service has keyword 'foreach'", name)
		}
		if srcUser && dstUser {
			ru.hasUser = "both"
			userUserCount++
		} else if srcUser {
			ru.hasUser = "src"
		} else {
			ru.hasUser = "dst"
		}
		ru.prt =
			c.expandProtocols(c.getValueList(v2.Prt, name), name)
		if a2 := v2.Log; a2 != nil {
			l := c.getValueList(a2, name)
			l = c.checkLog(l, name)
			ru.log = strings.Join(l, " ")
		}
		sv.rules = append(sv.rules, ru)
	}
	if len(sv.rules) == 0 {
		c.err("Must not define %s without any rules", name)
	} else if userUserCount > 0 && len(sv.rules) != userUserCount {
		c.err("Must not define %s having both user-user rule and normal rule",
			name)
	}
}

// Normalize list of log tags.
// - Sort tags,
// - remove duplicate elements and
// - remove unknown tags, not defined at any router.
func (c *spoc) checkLog(l stringList, ctx string) stringList {
	var valid stringList
	prev := ""
	slices.Sort(l)
	for _, tag := range l {
		if tag == prev {
			c.warn("Duplicate '%s' in log of %s", tag, ctx)
		} else if !c.symTable.knownLog[tag] {
			c.warn("Ignoring unknown '%s' in log of %s", tag, ctx)
		} else {
			prev = tag
			valid.push(tag)
		}
	}
	return valid
}

func (c *spoc) checkUserInUnion(l []ast.Element, ctx string) bool {
	count := c.countUser(l, ctx)
	if !(count == 0 || count == len(l)) {
		c.err("The sub-expressions of union in %s equally must\n"+
			" either reference 'user' or must not reference 'user'", ctx)
	}
	return count > 0
}

func (c *spoc) checkUserInIntersection(l []ast.Element, ctx string) bool {
	return c.countUser(l, ctx) > 0
}

func (c *spoc) countUser(l []ast.Element, ctx string) int {
	count := 0
	for _, el := range l {
		if c.hasUser(el, ctx) {
			count++
		}
	}
	return count
}

func (c *spoc) hasUser(el ast.Element, ctx string) bool {
	switch x := el.(type) {
	case *ast.User:
		return true
	case ast.AutoElem:
		return c.checkUserInUnion(x.GetElements(), ctx)
	case *ast.Intersection:
		return c.checkUserInIntersection(x.Elements, ctx)
	case *ast.Complement:
		return c.hasUser(x.Element, ctx)
	default:
		return false
	}
}

func splitTypedName(s string) (string, string) {
	typ, name, _ := strings.Cut(s, ":")
	return typ, name
}

// Make ID unique by appending name of enclosing network.
func fullHostname(hName, nName string) string {
	if strings.HasPrefix(hName, "host:id:") {
		hName += "." + nName
	}
	return hName
}

func (c *spoc) checkDuplicate(l []ast.Toplevel) {
	seen := make(map[string]string)
	check := func(name, fName string) {
		if where := seen[name]; where != "" {
			if fName != where {
				where += " and " + fName
			}
			c.err("Duplicate definition of %s in %s", name, where)
		}
		seen[name] = fName
	}
	for _, a := range l {
		topName := a.GetName()
		fileName := a.FileName()
		switch x := a.(type) {
		case *ast.Network:
			nName := topName[len("network:"):]
			for _, a := range x.Hosts {
				full := fullHostname(a.Name, nName)
				check(full, fileName)
			}
		}
		check(topName, fileName)
	}
}

func (c *spoc) checkDuplAttr(l *[]*ast.Attribute, ctx string) {
	seen := make(map[string]bool)
	j := 0
	for _, a := range *l {
		if seen[a.Name] {
			c.err("Duplicate attribute '%s' in %s", a.Name, ctx)
		} else {
			seen[a.Name] = true
			(*l)[j] = a
			j++
		}
	}
	*l = (*l)[:j]
}

func emptyAttr(a *ast.Attribute) bool {
	return a.ComplexValue == nil && a.ValueList == nil
}

func (c *spoc) getFlag(a *ast.Attribute, ctx string) bool {
	if !emptyAttr(a) {
		c.err("No value expected for flag '%s' of %s", a.Name, ctx)
	}
	return true
}

func (c *spoc) getSingleValue(a *ast.Attribute, ctx string) string {
	if a.ComplexValue != nil || len(a.ValueList) != 1 {
		c.err("Single value expected in '%s' of %s", a.Name, ctx)
		return ""
	}
	return a.ValueList[0].Value
}

func (c *spoc) getValueList(a *ast.Attribute, ctx string) stringList {
	if a.ComplexValue != nil || len(a.ValueList) == 0 {
		c.err("List of values expected in '%s' of %s", a.Name, ctx)
		return nil
	}
	result := make(stringList, 0, len(a.ValueList))
	for _, v := range a.ValueList {
		result.push(v.Value)
	}
	return result
}

func (c *spoc) getComplexValue(
	a *ast.Attribute, ctx string) []*ast.Attribute {

	aCtx := a.Name
	if ctx != "" {
		aCtx += " of " + ctx
	}
	l := a.ComplexValue
	if l == nil || a.ValueList != nil {
		c.err("Structured value expected in '%s'", aCtx)
	}
	c.checkDuplAttr(&l, aCtx)
	return l
}

func (c *spoc) getNATTags(a *ast.Attribute, ctx string) []string {
	l := c.getValueList(a, ctx)
	slices.Sort(l)
	// Remove duplicates.
	l2 := slices.Compact(l)
	if len(l) != len(l2) {
		c.warn("Ignoring duplicate element in %s", ctx)
	}
	return l2
}

func (c *spoc) getIdentifier(a *ast.Attribute, ctx string) string {
	v := c.getSingleValue(a, ctx)
	if !isSimpleName(v) {
		c.err("Invalid identifier in '%s' of %s: %s", a.Name, ctx, v)
	}
	return v
}

// Check for valid email address.
// Local part definition from wikipedia,
// without space and other quoted characters.
// Only 7 bit ASCII.
var emailRegex = regexp.MustCompile(
	"^[\\w.!#$%&\"*+\\/=?^_\\{|}~`-]+@[\\w.-]+$")

func (c *spoc) getEmailList(a *ast.Attribute, ctx string) []string {
	l := c.getValueList(a, ctx)
	for i, m := range l {
		switch {
		case emailRegex.MatchString(m):
		case m == "guest":
		case a.Name == "watchers":
			if loc, dom, found := strings.Cut(m, "@"); found {
				if loc == "[all]" && isDomain(dom) {
					break
				}
			}
			fallthrough
		default:
			c.err("Invalid email address (ASCII only) in %s of %s: %s",
				a.Name, ctx, m)
		}
		l[i] = strings.ToLower(m)
	}
	return c.removeDupl(l, a.Name+" of "+ctx)
}

// Setup standard time units with different names and plural forms.
var timeunits = map[string]int{
	"sec":    1,
	"second": 1,
	"min":    60,
	"minute": 60,
	"hour":   3600,
	"day":    86400,
}

func init() {
	for k, v := range timeunits {
		timeunits[k+"s"] = v
	}
}

// Read time value in different units, return seconds.
func (c *spoc) getTimeVal(a *ast.Attribute, ctx string) int {
	v := c.getSingleValue(a, ctx)
	l := strings.Split(v, " ")
	bad := func() int {
		c.err("Expected 'NUM sec|min|hour|day' in '%s' of %s", a.Name, ctx)
		return -1
	}
	if len(l) != 2 {
		return bad()
	}
	i, err := strconv.Atoi(l[0])
	if err != nil || i < 0 {
		return bad()
	}
	unit := l[1]
	factor, found := timeunits[unit]
	if !found {
		return bad()
	}
	return i * factor
}

func (c *spoc) getTimeKilobytesPair(a *ast.Attribute, ctx string) *[2]int {
	v := c.getSingleValue(a, ctx)
	l := strings.Split(v, " ")
	bad := func() int {
		c.err("Expected '[NUM sec|min|hour|day] [NUM kilobytes]' in '%s' of %s",
			a.Name, ctx)
		return 0
	}
	time := func(v1, v2 string) int {
		i, err := strconv.Atoi(v1)
		if err != nil || i < 0 {
			return bad()
		}
		unit := v2
		factor, found := timeunits[unit]
		if !found {
			return bad()
		}
		return i * factor
	}
	kbytes := func(v1, v2 string) int {
		i, err := strconv.Atoi(v1)
		if err != nil || i < 0 {
			return bad()
		}
		if v2 != "kilobytes" {
			return bad()
		}
		return i
	}
	sec := -1
	kb := -1
	switch len(l) {
	case 2:
		if l[1] == "kilobytes" {
			kb = kbytes(l[0], l[1])
		} else {
			sec = time(l[0], l[1])
		}
	case 4:
		sec = time(l[0], l[1])
		kb = kbytes(l[2], l[3])
	default:
		bad()
	}
	return &[2]int{sec, kb}
}

func (c *spoc) removeDupl(l []string, ctx string) []string {
	seen := make(map[string]bool)
	var dupl stringList
	j := 0
	for _, s := range l {
		if seen[s] {
			dupl.push(s)
		} else {
			seen[s] = true
			l[j] = s
			j++
		}
	}
	if dupl != nil {
		c.err("Duplicates in %s: %s", ctx, strings.Join(dupl, ", "))
	}
	return l[:j]
}

func (c *spoc) getManaged(a *ast.Attribute, ctx string) string {
	if emptyAttr(a) {
		return "standard"
	}
	v := c.getSingleValue(a, ctx)
	switch v {
	case "secondary", "standard", "full", "primary", "local", "routing_only", "":
		return v
	}
	c.err("Invalid value for '%s' of %s: %s", a.Name, ctx, v)
	return ""
}

var routerInfo = map[string]*model{
	"IOS": {
		routing:         "IOS",
		filter:          "IOS",
		stateless:       true,
		statelessSelf:   true,
		statelessICMP:   true,
		inversedACLMask: true,
		canVRF:          true,
		logModifiers: map[string]string{
			"<empty>":   "log",
			"log-input": "log-input"},
		hasOutACL:        true,
		needProtect:      true,
		crypto:           "IOS",
		printRouterIntf:  true,
		vrfShareHardware: true,
		commentChar:      "!",
	},
	"ASA": {
		routing: "ASA",
		filter:  "ASA",
		logModifiers: map[string]string{
			"<empty>":       "log",
			"emergencies":   "log 0",
			"alerts":        "log 1",
			"critical":      "log 2",
			"errors":        "log 3",
			"warnings":      "log 4",
			"notifications": "log 5",
			"informational": "log 6",
			"debugging":     "log 7",
			"disable":       "log disable",
		},
		statelessICMP:  true,
		hasOutACL:      true,
		aclUseRealIP:   true,
		canObjectgroup: true,
		canDynCrypto:   true,
		crypto:         "ASA",
		noCryptoFilter: true,
		commentChar:    "!",
		needACL:        true,
		noACLself:      true,
	},
	"PAN-OS": {
		routing: "",
		filter:  "PAN-OS",
		logModifiers: map[string]string{
			"start":    "start",
			"end":      "end",
			"setting:": ":insert",
		},
		canMultiLog:            true,
		hasIoACL:               true,
		canObjectgroup:         true,
		canVRF:                 true,
		needManagementInstance: true,
		needVRF:                true,
		noACLself:              true,
	},
	"NSX": {
		routing: "",
		filter:  "NSX",
		logModifiers: map[string]string{
			"<empty>": "logged",
			"tag:":    ":insert",
		},
		canObjectgroup:         true,
		canVRF:                 true,
		needManagementInstance: true,
		needVRF:                true,
		noACLself:              true,
		noSharedHardware:       true,
	},
	"Linux": {
		routing:     "iproute",
		filter:      "iptables",
		hasIoACL:    true,
		commentChar: "#",
	},
}

func init() {
	for name, info := range routerInfo {
		// Is changed for model with extension. Used in error messages.
		info.name = name
		// Is left unchanged with extensions. Used in header of generated files.
		info.class = name
	}
}

func (c *spoc) getModel(a *ast.Attribute, ctx string) *model {
	l := c.getValueList(a, ctx)
	m := l[0]
	attributes := l[1:]
	orig, found := routerInfo[m]
	if !found {
		c.err("Unknown model in %s: %s", ctx, m)

		// Prevent further errors.
		return &model{name: m}
	}
	info := *orig
	if len(attributes) != 0 {
		add := ""
		for _, att := range attributes {
			add += ", " + att
			switch m {
			case "IOS":
				switch att {
				case "FW":
					info.stateless = false
				default:
					goto FAIL
				}
			case "ASA":
				switch att {
				case "VPN":
					info.crypto = "ASA_VPN"
					info.doAuth = true
				case "CONTEXT":
					info.cryptoInContext = true
				default:
					goto FAIL
				}
			case "NSX":
				switch att {
				case "T0":
					info.tier = "0"
				case "T1":
					info.tier = "1"
				default:
					goto FAIL
				}
			default:
				goto FAIL
			}
			continue
		FAIL:
			c.err("Unknown extension in '%s' of %s: %s", a.Name, ctx, att)
		}
		info.name += add
	}
	return &info
}

// Definition of dynamic routing protocols.
var routingInfo = map[string]*mcastProto{
	"EIGRP": {
		name: "EIGRP",
		prt:  &proto{proto: "88", name: "proto 88"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.10"}},
			v6: multicast{ips: []string{"ff02::a"}}},
	},
	"OSPF": {
		name: "OSPF",
		prt:  &proto{proto: "89", name: "proto 89"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.5", "224.0.0.6"}},
			v6: multicast{ips: []string{"ff02::5", "ff02::6"}}},
	},
	"RIPv2": {
		name: "RIP",
		prt:  &proto{proto: "udp", ports: [2]int{520, 520}, name: "udp 520"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.9"}},
			v6: multicast{ips: []string{"ff02::9"}}},
	},
	"dynamic": {name: "dynamic"},

	// Identical to 'dynamic', but must only be applied to router, not
	// to routerIntf.
	"manual": {name: "manual"},
}

func init() {
	addMcastNetworks(routingInfo)
}

func (c *spoc) getRouting(a *ast.Attribute, ctx string) *mcastProto {
	v := c.getSingleValue(a, ctx)
	r := routingInfo[v]
	if r == nil {
		c.err("Unknown routing protocol in '%s' of %s", a.Name, ctx)
	}
	return r
}

// Definition of redundancy protocols.
var xxrpInfo = map[string]*mcastProto{
	"VRRP": {
		prt: &proto{proto: "112", name: "proto 112"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.18"}},
			v6: multicast{ips: []string{"ff02::12"}}},
	},
	"HSRP": {
		prt: &proto{proto: "udp", ports: [2]int{1985, 1985}, name: "udp 1985"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.2"}},

			// No official IPv6 multicast address for HSRP available,
			// therefore using IPv4 equivalent.
			v6: multicast{ips: []string{"::e000:2"}}},
	},
	"HSRPv2": {
		prt: &proto{proto: "udp", ports: [2]int{1985, 1985}, name: "udp 1985"},
		mcast: mcast{
			v4: multicast{ips: []string{"224.0.0.102"}},
			v6: multicast{ips: []string{"ff02::66"}}},
	},
}

func init() {
	addMcastNetworks(xxrpInfo)
}

func addMcastNetworks(info map[string]*mcastProto) {
	for _, mp := range info {
		process := func(m *multicast) {
			l := make([]*network, len(m.ips))
			for i, s := range m.ips {
				ip := netip.MustParseAddr(s)
				ipp := netip.PrefixFrom(ip, ip.BitLen())
				l[i] = &network{
					ipp:         ipp,
					withStdAddr: withStdAddr{stdAddr: ipp.String()},
				}
			}
			m.networks = l
		}
		process(&mp.v4)
		process(&mp.v6)
	}
}

func (c *spoc) getVirtual(a *ast.Attribute, v6 bool, ctx string,
) *routerIntf {
	virtual := new(routerIntf)
	virtual.name = ctx + ".virtual"
	virtual.redundant = true
	vCtx := "'" + a.Name + "' of " + ctx
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "ip", "ip6":
			if takeAttr46(a2, v6) {
				virtual.ip = c.getIp(a2, vCtx)
			}
		case "type":
			t := c.getSingleValue(a2, vCtx)
			p := xxrpInfo[t]
			if p == nil {
				c.err("Unknown redundancy protocol in %s", vCtx)
			}
			virtual.redundancyType = p
		case "id":
			id := c.getSingleValue(a2, vCtx)
			num, err := strconv.Atoi(id)
			if err != nil {
				c.err("Redundancy ID must be numeric in %s", vCtx)
			} else if !(num >= 0 && num < 256) {
				c.err("Redundancy ID must be > 0, < 256 in %s", vCtx)
			}
			virtual.redundancyId = id
		default:
			c.err("Unexpected attribute in %s: %s", vCtx, a2.Name)
		}
	}
	if !virtual.ip.IsValid() {
		c.err("Missing '%s' in %s", v6Attr("ip", v6), vCtx)
		return nil
	}
	if virtual.redundancyId != "" && virtual.redundancyType == nil {
		c.err("Redundancy ID is given without redundancy protocol in %s",
			vCtx)
	}
	return virtual
}

func isDomain(n string) bool {
	for _, part := range strings.Split(n, ".") {
		if !isSimpleName(part) {
			return false
		}
	}
	return n != ""
}

func isIdHostname(id string) bool {
	i := strings.Index(id, "@")
	// Leading "@" is ok.
	return (i <= 0 || isDomain(id[:i])) && isDomain(id[i+1:])
}

func isSimpleName(n string) bool {
	return n != "" && !strings.ContainsAny(n, ".:/@")
}

func (c *spoc) getIp(a *ast.Attribute, ctx string) netip.Addr {
	return c.convIP(c.getSingleValue(a, ctx), a.Name, ctx)
}

func (c *spoc) getIpList(a *ast.Attribute, ctx string) []netip.Addr {
	var result []netip.Addr
	for _, v := range c.getValueList(a, ctx) {
		result = append(result, c.convIP(v, a.Name, ctx))
	}
	return result
}

func (c *spoc) getIpRange(a *ast.Attribute, ctx string) netipx.IPRange {
	v := c.getSingleValue(a, ctx)
	rg, err := netipx.ParseIPRange(v)
	if err != nil {
		c.err("Invalid IP range in %s", ctx)
	}
	return rg
}

func (c *spoc) getIpPrefix(a *ast.Attribute, ctx string) netip.Prefix {
	v := c.getSingleValue(a, ctx)
	return c.convIpPrefix(v, a.Name, ctx)
}

func (c *spoc) getIpPrefixList(a *ast.Attribute, ctx string) []netip.Prefix {
	var result []netip.Prefix
	for _, v := range c.getValueList(a, ctx) {
		result = append(result, c.convIpPrefix(v, a.Name, ctx))
	}
	return result
}

func (c *spoc) convIpPrefix(s string, name, ctx string) netip.Prefix {
	n, err := netip.ParsePrefix(s)
	if err != nil {
		c.err("Invalid CIDR address: %s in '%s' of %s", s, name, ctx)
	} else if n.Masked() != n {
		c.err("IP and mask of %s don't match in '%s' of %s", s, name, ctx)
	}
	return n
}

func (c *spoc) convIP(s string, name, ctx string) netip.Addr {
	ip, err := netip.ParseAddr(s)
	if err != nil {
		c.err("Invalid IP address in '%s' of %s", name, ctx)
	}
	return ip
}

func (c *spoc) checkVxIP(ip netip.Addr, v6 bool, name, ctx string) {
	if v6 {
		if ip.Is4() {
			c.err("IPv6 address expected in attribute '%s' of %s", name, ctx)
		}
	} else if ip.Is6() {
		c.err("IPv4 address expected in attribute '%s' of %s", name, ctx)
	}
}

// Check if given date has been reached already.
var dateRegex = regexp.MustCompile(`^(\d\d\d\d-\d\d-\d\d)$`)

func (c *spoc) dateIsReached(s, ctx string) bool {
	l := dateRegex.FindStringSubmatch(s)
	if l == nil {
		c.err("Date expected as yyyy-mm-dd in %s", ctx)
		return false
	}
	date, err := time.ParseInLocation("2006-01-02", s, time.Local)
	if err != nil {
		c.err("Invalid date in %s: %v", ctx, err)
		return false
	}
	return time.Now().After(date)
}

func (c *spoc) getNetworkRef(a *ast.Attribute, ctx string) *network {
	return c.lookupNetworkRef(a, ctx, false)
}

func (c *spoc) tryNetworkRef(a *ast.Attribute, ctx string) *network {
	return c.lookupNetworkRef(a, ctx, true)
}

func (c *spoc) lookupNetworkRef(a *ast.Attribute, ctx string, warn bool,
) *network {
	typ, name := c.getTypedName(a, ctx)
	if typ == "" {
		return nil
	}
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "network" {
		c.err("Must only use network name in %s", ctx2)
		return nil
	}
	n := c.symTable.network[name]
	if n == nil {
		f := c.err
		if warn {
			f = c.warn
		}
		f("Referencing undefined network:%s in %s", name, ctx2)
		return nil
	}
	return n
}

func (c *spoc) tryNetworkRefList(a *ast.Attribute, ctx string) netList {
	l := c.getValueList(a, ctx)
	result := make(netList, 0, len(l))
	ctx2 := "'" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "network:")
		if len(name) == len(v) {
			c.err("Expected type 'network:' in %s", ctx2)
		} else if n, found := c.symTable.network[name]; found {
			result.push(n)
		} else {
			c.warn("Ignoring undefined network:%s in %s", name, ctx2)
		}
	}
	return result
}

func (c *spoc) tryHostRef(a *ast.Attribute, ctx string) *host {
	typ, name := c.getTypedName(a, ctx)
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "host" {
		c.err("Expected type 'host:' in %s", ctx2)
		return nil
	}
	h := c.symTable.host[name]
	if h == nil {
		c.warn("Ignoring undefined host:%s in %s", name, ctx2)
		return nil
	}
	return h
}

func (c *spoc) tryRouterRef(a *ast.Attribute, ctx string) *router {
	typ, name := c.getTypedName(a, ctx)
	ctx2 := "'" + a.Name + "' of " + ctx
	if typ != "router" {
		c.err("Expected type 'router:' in %s", ctx2)
		return nil
	}
	r := c.symTable.router[name]
	if r == nil {
		c.warn("Ignoring undefined router:%s in %s", name, ctx2)
		return nil
	}
	return r
}

func (c *spoc) combinedRouters(name string) []*router {
	if r, found := c.symTable.router[name]; found {
		if r2 := r.combined46; r2 != nil {
			return []*router{r, r2}
		}
		return []*router{r}
	} else {
		return nil
	}
}

func (c *spoc) getManagementInstance(r *router) *router {
	return c.symTable.router[r.deviceName]
}

func (c *spoc) getTypedName(a *ast.Attribute, ctx string) (string, string) {
	v := c.getSingleValue(a, ctx)
	typ, name, found := strings.Cut(v, ":")
	if !found {
		c.err("Typed name expected in '%s' of %s", a.Name, ctx)
		return "", ""
	}
	return typ, name
}

func (c *spoc) getRealOwnerRef(a *ast.Attribute, ctx string) *owner {
	o := c.tryOwnerRef(a, ctx)
	if o != nil {
		if o.admins == nil {
			c.err("Missing attribute 'admins' in %s of %s", o, ctx)
			o.admins = make([]string, 0)
		}
		if o.onlyWatch {
			c.err("%s with attribute 'only_watch' must only be used at area,\n"+
				" not at %s", o, ctx)
			o.onlyWatch = false
		}
	}
	return o
}

func (c *spoc) tryOwnerRef(a *ast.Attribute, ctx string) *owner {

	name := c.getSingleValue(a, ctx)
	o := c.symTable.owner[name]
	if o == nil {
		c.warn("Ignoring undefined owner:%s of %s", name, ctx)
	} else {
		o.isUsed = true
	}
	return o
}

func (c *spoc) getIsakmpRef(a *ast.Attribute, ctx string) *isakmp {

	typ, name := c.getTypedName(a, ctx)
	if typ != "isakmp" {
		c.err("Expected type 'isakmp:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	is := c.symTable.isakmp[name]
	if is == nil {
		c.err("Can't resolve reference to isakmp:%s in %s", name, ctx)
	}
	return is
}

func (c *spoc) getIpsecRef(a *ast.Attribute, ctx string) *ipsec {
	typ, name := c.getTypedName(a, ctx)
	if typ != "ipsec" {
		c.err("Expected type 'ipsec:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	is := c.symTable.ipsec[name]
	if is == nil {
		c.err("Can't resolve reference to ipsec:%s in %s", name, ctx)
	}
	return is
}

func (c *spoc) getCryptoRef(a *ast.Attribute, ctx string) *crypto {
	typ, name := c.getTypedName(a, ctx)
	if typ != "crypto" {
		c.err("Expected type 'crypto:' in '%s' of %s", a.Name, ctx)
		return nil
	}
	cr := c.symTable.crypto[name]
	if cr == nil {
		c.err("Can't resolve reference to crypto:%s in '%s' of %s",
			name, a.Name, ctx)
	}
	return cr
}

func (c *spoc) getCryptoRefList(a *ast.Attribute, ctx string) []*crypto {
	l := c.getValueList(a, ctx)
	result := make([]*crypto, 0, len(l))
	ctx2 := "'" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "crypto:")
		if len(name) == len(v) {
			c.err("Expected type 'crypto:' in %s", ctx2)
		} else if cr, found := c.symTable.crypto[name]; found {
			result = append(result, cr)
		} else {
			c.err("Can't resolve reference to crypto:%s in %s", name, ctx2)
		}
	}
	return result
}

func (c *spoc) tryServiceRefList(a *ast.Attribute, ctx string) []*service {
	l := c.getValueList(a, ctx)
	result := make([]*service, 0, len(l))
	ctx2 := "attribute '" + a.Name + "' of " + ctx
	for _, v := range l {
		name := strings.TrimPrefix(v, "service:")
		if len(name) == len(v) {
			c.err("Expected type 'service:' in %s", ctx2)
		} else if s, found := c.symTable.service[name]; found {
			result = append(result, s)
		} else {
			c.warn("Unknown '%s' in %s", v, ctx2)
		}
	}
	return result
}

func (c *spoc) getProtocolRef(name string, ctx string) *proto {
	p := c.symTable.protocol[name]
	if p == nil {
		c.err("Can't resolve reference to protocol:%s in %s", name, ctx)
	} else {
		p.isUsed = true
	}
	return p
}

func (c *spoc) getProtocolList(a *ast.Attribute, ctx string) protoList {
	l := c.getValueList(a, ctx)
	ctx2 := a.Name + " of " + ctx
	return c.expandProtocols(l, ctx2)
}

func (c *spoc) expandProtocols(l stringList, ctx string) protoList {
	var result protoList
	for _, v := range l {
		if name, found := strings.CutPrefix(v, "protocol:"); found {
			if p := c.getProtocolRef(name, ctx); p != nil {
				result.push(p)
			}
		} else if name, found := strings.CutPrefix(v, "protocolgroup:"); found {
			result = append(result, c.expandProtocolgroup(name, ctx)...)
		} else {
			ctx2 := "'" + v + "' of " + ctx
			p := c.getSimpleProtocol(v, ctx2)
			result.push(p)
		}
	}
	// Ignore duplicates
	seen := make(map[*proto]bool)
	j := 0
	for _, p := range result {
		pm := p
		if p2 := p.main; p2 != nil && p.modifiers == nil {
			pm = p2
		}
		if seen[pm] {
			c.warn("Ignoring duplicate '%s' in %s", pm.name, ctx)
		} else {
			result[j] = p
			j++
			seen[pm] = true
		}
	}
	return result[:j]
}

func (c *spoc) expandProtocolgroup(name string, ctx string) protoList {
	g, found := c.symTable.protocolgroup[name]
	if !found {
		c.err("Can't resolve reference to protocolgroup:%s in %s", name, ctx)
		return nil
	}
	if g.recursive {
		c.err("Found recursion in definition of %s", ctx)
	} else if !g.isUsed {
		g.isUsed = true
		g.recursive = true
		ctx2 := "protocolgroup:" + name
		g.elements = c.expandProtocols(g.list, ctx2)
		g.recursive = false
	}
	return g.elements
}

func (c *spoc) cacheUnnamedProtocol(p *proto) *proto {
	name := genProtocolName(p)
	if cached, found := c.symTable.unnamedProto[name]; found {
		return cached
	}
	p.name = name
	c.symTable.unnamedProto[name] = p
	return p
}

// Creates a readable, unique name for passed protocol,
// e.g. "tcp 80" for { proto : "tcp", ports: [80, 80] }.
func genProtocolName(p *proto) string {
	pr := p.proto
	switch pr {
	case "ip":
		return pr
	case "tcp", "udp":
		n := p.ports
		return jcode.GenPortName(pr, n[0], n[1])
	case "icmp", "icmpv6":
		result := pr
		if p.icmpType != -1 {
			result += " " + strconv.Itoa(p.icmpType)
			if p.icmpCode != -1 {
				result += "/" + strconv.Itoa(p.icmpCode)
			}
		}
		return result
	default:
		return "proto " + pr
	}
}

func (c *spoc) getVPNAttributes(a *ast.Attribute, ctx string) map[string]string {
	result := make(map[string]string)
	rCtx := a.Name + " of " + ctx
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		k := a2.Name
		if !isSimpleName(k) {
			c.err("Invalid identifier '%s' in %s", k, rCtx)
		}
		v := ""
		if len(a2.ValueList) == 1 {
			v = a2.ValueList[0].Value
		}
		result[k] = v
	}
	return result
}

func (c *spoc) getRouterAttributes(a *ast.Attribute, ar *area) routerAttributes {
	ctx := ar.name
	var r routerAttributes
	name := "router_attributes of " + ctx
	r.name = name
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "owner":
			r.owner = c.getRealOwnerRef(a2, name)
		case "policy_distribution_point":
			r.policyDistributionPoint = c.tryHostRef(a2, name)
		case "general_permit":
			r.generalPermit = c.getGeneralPermit(a2, name)
		default:
			c.err("Unexpected attribute in %s: %s", name, a2.Name)
		}
	}
	return r
}

func (c *spoc) getGeneralPermit(a *ast.Attribute, ctx string) protoList {
	l := c.getProtocolList(a, ctx)
	for i, p := range l {
		// Check for protocols not valid for general_permit.
		// Don't allow port ranges. This wouldn't work, because
		// genReverseRules doesn't handle generally permitted protocols.
		var reason stringList
		srcRange := false
		if m := p.modifiers; m != nil {
			if m.srcRange == nil {
				reason.push("modifiers")
			} else {
				srcRange = true
			}
		}
		name := p.name
		if p2 := p.main; p2 != nil {
			p = p2
			l[i] = p
		}
		if srcRange ||
			p.ports[0] != 0 && !(p.ports[0] == 1 && p.ports[1] == 65535) {
			reason.push("ports")
		}
		if reason != nil {
			c.err("Must not use '%s' with %s in general_permit of %s",
				name, strings.Join(reason, " or "), ctx)
		}
	}
	// Sort protocols by name, so we can compare value lists of
	// attribute general_permit for redundancy during inheritance.
	slices.SortFunc(l, func(a, b *proto) int {
		return strings.Compare(a.name, b.name)
	})
	return l
}

func (c *spoc) checkGeneralPermit() {
	for _, r := range c.allRouters {
		r.generalPermit = c.checkProtoListV4V6(
			r.generalPermit, r.ipV6, r.isCombined46(),
			"general_permit of "+r.name)
	}
	for _, ar := range c.ascendingAreas {
		ar.routerAttributes.generalPermit = c.checkProtoListV4V6(
			ar.routerAttributes.generalPermit, ar.ipV6, ar.isCombined46(),
			"general_permit of router_attributes of "+ar.name)
	}
}

// Check if protocols are valid in IPv4 / IPv6 context.
// If parameter is46 is set, protocols icmp and icmp6 are silently
// removed from result list.
func (c *spoc) checkProtoListV4V6(l protoList, v6, is46 bool, ctx string,
) protoList {
	var result protoList
	for _, p := range l {
		if v6 {
			switch p.proto {
			default:
				result.push(p)
				continue
			case "icmp":
				if is46 {
					continue
				}
			case "58":
			}
			c.err("'%s' must not be used in %s, use 'icmpv6' instead", p.name, ctx)
		} else {
			switch p.proto {
			default:
				result.push(p)
				continue
			case "icmpv6":
				if is46 {
					continue
				}
			case "1":
			}
			c.err("'%s' must not be used in %s, use 'icmp' instead", p.name, ctx)
		}
	}
	return result
}

func (c *spoc) getLogModifiers(a *ast.Attribute, ctx string) string {
	if emptyAttr(a) {
		return "<empty>"
	}
	return strings.Join(c.getValueList(a, ctx), " ")
}

func (c *spoc) addLog(a *ast.Attribute, r *router) bool {
	if name, found := strings.CutPrefix(a.Name, "log:"); found {
		m := r.log
		if m == nil {
			m = make(map[string]string)
			r.log = m
		}
		c.symTable.knownLog[name] = true
		m[name] = c.getLogModifiers(a, r.name)
		return true
	}
	return false
}

// Check log modifiers and transform to log code.
func (c *spoc) transformLog(name, modList string, r *router) string {
	knownMod := r.model.logModifiers
	if knownMod == nil {
		c.err("Must not use attribute '%s' at %s of model %s",
			name, r, r.model.name)
		return ""
	}
	l := strings.Split(modList, " ")
	if len(l) > 1 && !r.model.canMultiLog {
		c.err("Must not use multiple values for %s in %s of model %s",
			name, r, r.model.name)
		return ""
	}
	for i, mod := range l {
		k := mod
		// Check for KEY:VALUE
		if i := strings.Index(mod, ":"); i != -1 {
			k = mod[:i+1]
			if len(k) == len(mod) {
				c.err(
					"Must give some value after ':' in '%s' of %s in %s",
					mod, name, r)
			}
		}
		if v, found := knownMod[k]; found {
			if v == ":insert" {
				// Substitute special value ":insert" by original KEY:VALUE.
				v = mod
			}
			l[i] = v
			continue
		}

		// Show error message for unknown log tag.
		what := fmt.Sprintf("'%s = %s' at %s of model %s",
			name, mod, r.name, r.model.name)
		valid := slices.Sorted(maps.Keys(knownMod))
		oneOf := cond(r.model.canMultiLog, "", " one of")
		c.err("Invalid %s\n Expected%s: %s",
			what, oneOf, strings.Join(valid, "|"))
	}
	return strings.Join(l, " ")
}

func (c *spoc) addAttr(a *ast.Attribute, attr *attrStore, ctx string) bool {
	var k attrKey
	switch a.Name {
	default:
		return false
	case "overlaps":
		k = overlapsAttr
	case "identical_body":
		k = identicalBodyAttr
	case "unknown_owner":
		k = unknownOwnerAttr
	case "multi_owner":
		k = multiOwnerAttr
	case "has_unenforceable":
		k = hasUnenforceableAttr
	}
	v := c.getSingleValue(a, ctx)
	var at attrVal
	switch v {
	default:
		c.err("Expected 'restrict', 'enable' or 'ok' in '%s' of %s", a.Name, ctx)
	case "restrict":
		at = restrictVal
	case "enable":
		at = enableVal
	case "ok":
		at = okVal
	}
	attr[k] = at
	return true
}

func (c *spoc) addNetNat(a *ast.Attribute, m natTagMap, ctx string) natTagMap {
	return c.addXNat(a, m, ctx, c.getIpPrefix)
}
func (c *spoc) addIntfNat(a *ast.Attribute, m natTagMap, ctx string) natTagMap {
	return c.addXNat(a, m, ctx,
		func(a *ast.Attribute, ctx string) netip.Prefix {
			addr := c.getSingleValue(a, ctx)
			ip := c.convIP(addr, a.Name, ctx)
			return netip.PrefixFrom(ip, ip.BitLen())
		})
}

func (c *spoc) addXNat(
	a *ast.Attribute, m natTagMap, ctx string,
	getIpX func(*ast.Attribute, string) netip.Prefix,
) natTagMap {

	tag, found := strings.CutPrefix(a.Name, "nat:")
	if !found {
		return nil
	}
	nat := new(network)
	natCtx := a.Name + " of " + ctx
	ipGiven := false
	l := c.getComplexValue(a, ctx)
	for _, a2 := range l {
		switch a2.Name {
		case "ip":
			ipGiven = true
			nat.ipp = getIpX(a2, natCtx)
		case "hidden":
			nat.hidden = c.getFlag(a2, natCtx)
			if len(l) != 1 {
				c.err("Hidden NAT must not use other attributes in %s", natCtx)
			}
			// This simplifies error checks for overlapping addresses.
			nat.dynamic = true
			// Provide an unusable address (currently ipv4 only).
			nat.ipp = netip.PrefixFrom(getZeroIp(false), getHostPrefix(false))
		case "identity":
			nat.identity = c.getFlag(a2, natCtx)
			if len(l) != 1 {
				c.err("Identity NAT must not use other attributes in %s", natCtx)
			}
			nat.dynamic = true
		case "dynamic":
			nat.dynamic = c.getFlag(a2, natCtx)
		case "subnet_of":
			nat.subnetOf = c.tryNetworkRef(a2, natCtx)
		default:
			c.err("Unexpected attribute in %s: %s", natCtx, a2.Name)
		}
	}
	if !nat.identity && !nat.hidden && !ipGiven {
		c.err("Missing IP address in %s", natCtx)
	}

	// Attribute .natTag is used later to look up static translation
	// of hosts inside a dynamically translated network.
	nat.natTag = tag

	nat.name = ctx
	nat.descr = "nat:" + tag + " of " + ctx
	if m == nil {
		m = make(natTagMap)
	}
	m[tag] = nat
	return m
}

func (c *spoc) addIPNat(a *ast.Attribute, m map[string]netip.Addr, ctx string,
) map[string]netip.Addr {
	tag, found := strings.CutPrefix(a.Name, "nat:")
	if !found {
		return nil
	}
	if m == nil {
		m = make(map[string]netip.Addr)
	}
	natCtx := a.Name + " of " + ctx
	l := c.getComplexValue(a, ctx)
	if len(l) != 1 || l[0].Name != "ip" {
		c.err("Expecting exactly one attribute 'ip' in %s", natCtx)
		return m
	}
	m[tag] = c.getIp(l[0], natCtx)
	return m
}

func (c *spoc) checkInterfaceIp(intf *routerIntf, n *network) {
	if intf.ipType == unnumberedIP {
		if n.ipType != unnumberedIP {
			c.err("Unnumbered %s must not be linked to %s", intf, n)
		}
		return
	}
	if n.ipType == unnumberedIP {
		c.err("%s must not be linked to unnumbered %s", intf, n)
		return
	}
	if intf.ipType != hasIP {
		// Nothing to be checked: attribute 'bridged' is set automatically
		// for an interface without IP and linked to bridged network.
		return
	}

	ipp := n.ipp
	// Network has invalid IP address. Error was already shown.
	if !ipp.IsValid() {
		return
	}

	// Check compatibility of interface IP and network address.
	ip := intf.ip
	if !ipp.Contains(ip) {
		c.err("%s address of %s doesn't match %s", ipvx(intf.ipV6), intf, n)
	}
	if ipp.IsSingleIP() {
		c.warn("%s has address of its network.\n"+
			" Remove definition of %s and\n"+
			" add attribute 'loopback' at interface definition.",
			intf, n)
	} else if n.ipType == hasIP && n.ipp.Addr().Is4() {

		// Check network and broadcast address only for IPv4,
		// but not for /31 IPv4 (see RFC 3021).
		if n.ipp.Bits() != 31 {
			if ip == n.ipp.Addr() {
				c.err("%s has address of its network", intf.vxName())
			}
			if ip == netipx.RangeOfPrefix(n.ipp).To() {
				c.err("%s has broadcast address", intf.vxName())
			}
		}
	}
}

// checkNoInAcl moves attribute 'no_in_acl'
// from interface to hardware	because ACLs operate on hardware, not on logic.
//
//	Marks hardware needing outgoing ACLs.
//
// Comment: Not more than one 'no_in_acl' interface per router allowed.
func (c *spoc) checkNoInAcl(r *router) {
	count := 0
	hasCrypto := false
	var rerouteIntf *routerIntf

	// Move attribute no_in_acl to hardware.
	for _, intf := range r.interfaces {
		if intf.spoke != nil || intf.hub != nil {
			hasCrypto = true
		}
		if intf.reroutePermit != nil && !intf.noInAcl {
			rerouteIntf = intf
		}
		if !intf.noInAcl {
			continue
		}
		hw := intf.hardware

		// Prevent duplicate error message.
		if hw.noInAcl {
			continue
		}
		hw.noInAcl = true

		// Assure max number of main interfaces at no_in_acl-hardware == 1.
		if len(hw.interfaces) != 1 {
			c.err("Only one logical interface allowed at hardware '%s' of %s\n"+
				" because of attribute 'no_in_acl'", hw.name, r)
		}
		count++

		// Reference no_in_acl interface in router attribute.
		r.noInAcl = intf
	}
	if count == 0 {
		return
	}

	// Assert maximum number of 'no_in_acl' interfaces per router
	if count != 1 {
		c.err("At most one interface of %s may use flag 'no_in_acl'", r)
	}

	// Assert router to support outgoing ACL
	if !r.model.hasOutACL {
		c.err("%s doesn't support outgoing ACL", r)
	}

	// reroute_permit would generate permit any -> networks,
	// but no_in_acl would generate permit any -> any anyway.
	if r.noInAcl.reroutePermit != nil {
		c.warn("Useless 'reroute_permit' together with 'no_in_acl' at %s",
			r.noInAcl.name)
	}

	// Must not use reroute_permit to network N together with no_in_acl.
	// In this case incoming traffic at no_in_acl interface
	// to network N wouldn't be filtered at all.
	if rerouteIntf != nil {
		c.err("Must not use attributes no_in_acl and reroute_permit"+
			" together at %s\n"+
			" Add incoming and outgoing ACL line in raw file instead.", r)
	}

	// Assert router not to take part in crypto tunnels.
	if hasCrypto {
		c.err(
			"Don't use attribute 'no_in_acl' together with crypto tunnel at %s",
			r)
	}

	// Mark other hardware with attribute 'needOutAcl'.
	for _, hw := range r.hardware {
		if !hw.noInAcl {
			hw.needOutAcl = true
		}
	}
}

// No traffic must traverse crypto interface.
// Hence split router into separate instances, one instance for each
// crypto interface.
// Split routers are tied by identical attribute .deviceName.
func (c *spoc) moveLockedIntf(intf *routerIntf) {
	orig := intf.router

	// Use different and uniqe name for each split router.
	name := "router:" + intf.name[len("interface:"):]
	cp := *orig
	cp.name = name
	cp.origRouter = orig
	cp.interfaces = intfList{intf}
	intf.router = &cp
	c.allRouters.push(&cp)

	// Don't check fragment for reachability.
	cp.policyDistributionPoint = nil

	// vpnAttributes are only needed at origRouter, where crypto
	// tunnels are attached.
	cp.vpnAttributes = nil

	// Remove interface from old router.
	// Retain original interfaces.
	l := orig.interfaces
	if orig.origIntfs == nil {
		orig.origIntfs = l
	}
	orig.interfaces = make(intfList, 0, len(l)-1)
	for _, intf2 := range l {
		if intf2 != intf {
			orig.interfaces.push(intf2)
		}
	}

	if orig.managed != "" {
		for _, intf2 := range intf.hardware.interfaces {
			if intf2 != intf && intf2.ipType != tunnelIP {
				c.err("Crypto %s must not share hardware with other %s",
					intf, intf2)
				break
			}
		}
	}
}

// Link tunnel networks with tunnel hubs.
func (c *spoc) linkTunnels() {
	// Sorting needed for deterministic error messages.
	l := slices.SortedFunc(maps.Values(c.symTable.crypto),
		func(a, b *crypto) int { return cmp.Compare(a.name, b.name) })
	for _, cr := range l {
		realHub := cr.hub
		if realHub == nil {
			c.warn("No hub has been defined for %s", cr.name)
			continue
		}
		tunnels := cr.tunnels
		if len(tunnels) == 0 {
			c.warn("No spokes have been defined for %s", cr.name)
		}

		isakmp := cr.ipsec.isakmp
		needId := isakmp.authentication == "rsasig"

		// Note: Crypto router is split internally into two nodes.
		// Typically we get get a node with only a single crypto interface.
		// Take original router with cleartext interface(s).
		r := realHub.router
		if orig := r.origRouter; orig != nil {
			r = orig
		}
		model := r.model
		rName := r.name[len("router:"):]

		// Router of type 'doAuth' can only check certificates,
		// not pre-shared keys.
		if model.doAuth && !needId {
			c.err("%s needs authentication=rsasig in %s", r, isakmp.name)
		}

		// Generate a single tunnel from each spoke to single hub.
		for _, spokeNet := range tunnels {
			netName := spokeNet.name[len("network:"):]
			spoke := spokeNet.interfaces[0]
			realSpoke := spoke.realIntf

			hw := realHub.hardware
			hub := new(routerIntf)
			hub.name = "interface:" + rName + "." + netName
			hub.ipType = tunnelIP
			// Attention: shared hardware between router and origRouter.
			hub.hardware = hw
			hub.isHub = true
			hub.realIntf = realHub
			hub.router = r
			hub.network = spokeNet
			hub.natOutgoing = cr.natOutgoing
			hub.routing = realHub.routing
			hub.peer = spoke
			spoke.peer = hub
			r.interfaces.push(hub)
			hw.interfaces.push(hub)
			spokeNet.interfaces.push(hub)

			// We need hub also be available in origIntfs.
			if r.origIntfs != nil {
				r.origIntfs.push(hub)
			}

			if !realSpoke.ip.IsValid() {
				if !(model.doAuth || model.canDynCrypto) {
					c.err(
						"%s can't establish crypto tunnel to %s with unknown IP",
						r, realSpoke)
				}
			}
		}
	}
}

// Collect groups of virtual interfaces
// - be connected to the same network and
// - having the same IP address.
// Link all virtual interfaces to the group of member interfaces.
// Check consistency:
// - Member interfaces must use identical protocol and identical ID.
// - The same ID must not be used by some other group
//   - connected to the same network
//   - emploing the same redundancy type
func (c *spoc) linkVirtualInterfaces() {
	process := func(n *network) {
		// Collect virtual interfaces with same IP in current network.
		ip2virtual := make(map[netip.Addr]intfList)

		// Look up virtual interface of a group inside the same network and
		// using the same ID and type.
		type key2 struct {
			id  string
			typ *mcastProto
		}
		idType2virtual := make(map[key2]*routerIntf)
		for _, v1 := range n.interfaces {
			if !v1.redundant {
				continue
			}
			ip := v1.ip
			t1 := v1.redundancyType
			id1 := v1.redundancyId
			l := ip2virtual[ip]
			if l != nil {
				v2 := l[0]
				t2 := v2.redundancyType
				if t1 != t2 {
					c.err("Must use identical redundancy protocol at\n"+
						" - %s\n"+
						" - %s", v2, v1)
				}
				id2 := v2.redundancyId
				if id1 != id2 {
					c.err("Must use identical ID at\n"+
						" - %s\n"+
						" - %s", v2, v1)
				}
			} else if id1 != "" {
				// Check for identical ID used at unrelated virtual
				// interfaces inside current network.
				k2 := key2{id1, t1}
				if v2 := idType2virtual[k2]; v2 != nil {
					c.err("Must use different ID at unrelated\n"+
						" - %s\n"+
						" - %s", v2, v1)
				} else {
					idType2virtual[k2] = v1
				}
			}
			l.push(v1)
			ip2virtual[ip] = l
		}
		for _, l := range ip2virtual {
			for _, intf := range l {
				intf.redundancyIntfs = l
			}
		}

		// Automatically add pathrestriction to each group of virtual
		// interfaces, where at least one interface is managed.
		// Pathrestriction would be useless if all devices are unmanaged.
		for _, l := range ip2virtual {
			if len(l) < 2 {
				continue
			}
			for _, intf := range l {
				r := intf.router
				if r.managed != "" || r.routingOnly {
					name := "auto-virtual:" + intf.ip.String()
					c.addPathrestriction(name, l)
					break
				}
			}
		}
	}
	for _, n := range c.symTable.network {
		process(n)
	}
}

func (c *spoc) addPathrestriction(name string, l intfList) *pathRestriction {
	pr := new(pathRestriction)
	pr.name = name
	pr.elements = l
	c.pathrestrictions = append(c.pathrestrictions, pr)
	for _, intf := range l {
		// Unmanaged router with pathrestriction is handled specially.
		// It is separating zones, but gets no code.
		if intf.router.managed == "" {
			intf.router.semiManaged = true
			// Change to non nil value, so we can detect pathrestricted interfaces
			// during splitSemiManagedRouters.
			// Real value is added later.
			intf.pathRestrict = []*pathRestriction{}
		}
	}
	return pr
}
