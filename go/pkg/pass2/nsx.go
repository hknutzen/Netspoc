package pass2

import (
	"encoding/json"
	"fmt"
	"golang.org/x/exp/maps"
	"os"
	"sort"
	"strconv"
	"strings"
)

type jsonMap map[string]interface{}

func printNSXRules(fd *os.File, rData *routerData) {

	// Remove redundant rules and find object-groups.
	prepareACLs(rData)

	for _, acl := range rData.acls {
		joinRanges(acl)
		findObjectgroups(acl, rData)
		addFinalPermitDenyRule(acl)
	}

	// Print JSON.
	getAction := func(ru *ciscoRule) string {
		if ru.deny {
			return "DROP"
		} else {
			return "ALLOW"
		}
	}
	single := func(s string) []string { return []string{s} }
	var getAddress func(n *ipNet) []string
	getAddress = func(n *ipNet) []string {
		// Object group.
		if !n.Prefix.IsValid() {
			return single("Netspoc-" + n.name)
		}
		if n.Bits() == 0 {
			return single("ANY")
		}
		if n.IsSingleIP() {
			return single(n.Addr().String())
		}
		return single(n.String())
	}
	type srcRgPrt struct {
		srcRg *proto
		prt   *proto
		name  string
	}
	protoMap := make(map[string]srcRgPrt)
	getService := func(ru *ciscoRule) string {
		prt := ru.prt
		proto := prt.protocol
		if proto == "ip" {
			return "ANY"
		}
		var name string
		srcRange := ru.srcRange
		if srcRange != nil {
			var dPorts string
			if len(prt.name) > len(proto) {
				dPorts = prt.name[len(proto)+1:]
			} else {
				dPorts = "1-65535"
			}
			name = srcRange.name + ":" + dPorts
		} else {
			name = prt.name
		}
		// Prevent name clash between IPv4 and IPv6 version of icmp protocol.
		if rData.ipv6 && proto == "icmp" {
			name = strings.Replace(name, "icmp", "icmpv6", 1)
		}
		name = "Netspoc-" + name
		protoMap[name] = srcRgPrt{prt: prt, srcRg: srcRange}
		return name
	}
	getPolicies := func(l []*aclInfo) []jsonMap {
		var result []jsonMap
		// Collect rules of each firewall into a separate policy.
		pm := make(map[string][]*aclInfo)
		for _, acl := range l {
			pm[acl.vrf] = append(pm[acl.vrf], acl)
		}
		vrfs := maps.Keys(pm)
		sort.Strings(vrfs)
		for _, vrf := range vrfs {
			acls := pm[vrf]
			scope := fmt.Sprintf("/infra/tier-%ss/%s", acls[0].tier, vrf)
			var nsxRules []jsonMap
			ruleNum := 1
			for _, acl := range acls {
				hardware := strings.TrimSuffix(acl.name, "_in")
				direction := "IN"
				if hardware == "IN" {
					direction = "OUT"
				}
				// From gateway firewall documentation:
				// If there are multiple rules with the same sequence
				// number then their order is not deterministic. If a
				// specific order of rules is desired, then one has to
				// specify unique sequence numbers.
				//
				// Netspoc assumes that rules are checked in list order.
				// But we don't need to add a sequence number for each
				// rule. Only when the action of a rule changes, the
				// sequence must be preserved.
				//
				// Hence we use these sequence numers for rules
				// generated by Netspoc:
				// - 10 for prepended DROP rules
				// - 20 for plain ACCEPT rules
				// - 30 for final DROP rule
				//
				// For additional rules from raw file, intermediate
				// sequence numbers like 5, 15, 25, 35 should be used.
				seqNum := 20
				isDeny := acl.rules[0].deny
				if isDeny {
					if len(acl.rules) > 1 {
						seqNum = 10
					} else {
						seqNum = 30
					}
				}
				for _, rule := range acl.rules {
					if isDeny != rule.deny {
						seqNum += 10
						isDeny = rule.deny
					}
					rName := fmt.Sprintf("r%d", ruleNum)
					ruleNum++
					// Prevent name clash between IPv4 and IPv6 rules
					if rData.ipv6 {
						rName = "v6" + rName
					}
					nsxRule := jsonMap{
						"resource_type":      "Rule",
						"id":                 rName,
						"action":             getAction(rule),
						"source_groups":      getAddress(rule.src),
						"destination_groups": getAddress(rule.dst),
						"services":           single(getService(rule)),
						"scope":              single(scope),
						"direction":          direction,
						"sequence_number":    seqNum,
					}
					nsxRules = append(nsxRules, nsxRule)
				}
			}
			policyName := "Netspoc-" + vrf
			path := "/infra/domains/default/gateway-policies/" + policyName
			result = append(result, jsonMap{
				"resource_type": "GatewayPolicy",
				"path":          path,
				"id":            policyName,
				"display_name":  policyName,
				"rules":         nsxRules,
			})
		}
		return result
	}
	getGroups := func() []jsonMap {
		var result []jsonMap
		for _, acl := range rData.acls {
			for _, g := range acl.objectGroups {
				var l []string
				for _, n := range g.elements {
					l = append(l, getAddress(n)...)
				}
				path := "/infra/domains/default/groups/" + "Netspoc-" + g.name
				addresses := jsonMap{
					"resource_type": "IPAddressExpression",
					"ip_addresses":  l,
				}
				result = append(result, jsonMap{
					"path":       path,
					"expression": []jsonMap{addresses},
				})
			}
		}
		return result
	}
	getServices := func() []jsonMap {
		var result []jsonMap
		names := maps.Keys(protoMap)
		sort.Strings(names)
		for _, name := range names {
			pair := protoMap[name]
			p := pair.prt
			proto := p.protocol
			svcEntry := jsonMap{}
			switch proto {
			case "tcp", "udp":
				svcEntry["resource_type"] = "L4PortSetServiceEntry"
				svcEntry["l4_protocol"] = strings.ToUpper(proto)
				if len(p.name) > len(proto) {
					ports := p.name[len(proto)+1:]
					svcEntry["destination_ports"] = single(ports)
				}
				if s := pair.srcRg; s != nil {
					ports := s.name[len(s.protocol)+1:]
					svcEntry["source_ports"] = single(ports)
				}
			case "icmp":
				svcEntry["resource_type"] = "IcmpTypeServiceEntry"
				var icmpProto string
				if rData.ipv6 {
					icmpProto = "ICMPv6"
				} else {
					icmpProto = "ICMPv4"
				}
				svcEntry["protocol"] = icmpProto

				if typ := p.icmpType; typ != -1 {
					svcEntry["icmp_type"] = typ
					if code := p.icmpCode; code != -1 {
						svcEntry["icmp_code"] = code
					}
				}
			default:
				svcEntry["resource_type"] = "IpProtocolServiceEntry"
				svcEntry["protocol_number"], _ = strconv.Atoi(proto)
			}
			path := "/infra/services/" + name
			result = append(result, jsonMap{
				"display_name":    name,
				"path":            path,
				"service_entries": []jsonMap{svcEntry},
			})
		}
		return result
	}

	fmt.Fprintln(fd)
	s2 := getPolicies(rData.acls)
	s1 := getGroups()
	s1 = append(s1, getServices()...)
	s1 = append(s1, s2...)
	enc := json.NewEncoder(fd)
	enc.SetIndent("", " ")
	enc.SetEscapeHTML(false)
	enc.Encode(s1)
	fmt.Fprintln(fd)
}

func printCombinedNSX(fd *os.File, config []string, rData *routerData) {
	// Print config and insert printed configuration at aclMarker.
	for _, line := range config {
		if strings.HasPrefix(line, aclMarker) {
			// Print rules.
			printNSXRules(fd, rData)
		} else {
			// Print unchanged config line.
			fmt.Fprintln(fd, line)
		}
	}
}
