package pass2

import (
	"encoding/json"
	"fmt"
	"maps"
	"os"
	"slices"
	"strconv"
	"strings"
)

type jsonMap map[string]interface{}

func printNSXRules(fd *os.File, rData *routerData) {
	prepareACLs(rData)
	for _, acl := range rData.acls {
		optimizeRules(acl)
		joinRanges(acl)
		hasFinalPermit := checkFinalPermit(acl)
		findObjectgroups(acl, rData)
		if len(acl.filterOnly) > 0 && !acl.addPermit {
			addLocalDenyRules(acl, rData)
		} else if !hasFinalPermit {
			addFinalPermitDenyRule(acl)
		}
	}

	// Print JSON.
	getAction := func(ru *ciscoRule) string {
		if ru.deny {
			return "DROP"
		} else {
			return "ALLOW"
		}
	}
	single := func(s string) []string { return []string{s} }
	getAddress := func(n *ipNet) []string {
		// Object group.
		if !n.Prefix.IsValid() {
			return single("/infra/domains/default/groups/Netspoc-" + n.name)
		}
		if n.Bits() == 0 {
			return single("ANY")
		}
		if n.IsSingleIP() {
			return single(n.Addr().String())
		}
		return single(n.String())
	}
	type srcRgPrt struct {
		srcRg *proto
		prt   *proto
	}
	protoMap := make(map[string]srcRgPrt)
	getService := func(ru *ciscoRule) string {
		prt := ru.prt
		proto := prt.protocol
		if proto == "ip" {
			return "ANY"
		}
		var name string
		srcRange := ru.srcRange
		if srcRange != nil {
			var dPorts string
			if len(prt.name) > len(proto) {
				dPorts = prt.name[len(proto)+1:]
			} else {
				dPorts = "1-65535"
			}
			name = srcRange.name + ":" + dPorts
		} else {
			name = prt.name
		}
		// Prevent name clash between IPv4 and IPv6 version of icmp protocol.
		if rData.ipv6 && proto == "icmp" {
			name = strings.Replace(name, "icmp", "icmpv6", 1)
		}
		name = strings.Replace(name, " ", "_", 1)
		name = "Netspoc-" + name
		protoMap[name] = srcRgPrt{prt: prt, srcRg: srcRange}
		return "/infra/services/" + name
	}
	addLog := func(ru *ciscoRule, j jsonMap, aclInfo *aclInfo) {
		modifier := ru.log
		if modifier == "" && ru.deny {
			modifier = aclInfo.logDeny
		}
		if modifier != "" {
			j["logged"] = true
			if k, v, found := strings.Cut(modifier, ":"); found {
				j[k] = v
			}
		}
	}
	getPolicies := func(l []*aclInfo) []jsonMap {
		var result []jsonMap
		// Collect rules of each firewall into a separate policy.
		pm := make(map[string][]*aclInfo)
		for _, acl := range l {
			pm[acl.vrf] = append(pm[acl.vrf], acl)
		}
		for _, vrf := range slices.Sorted(maps.Keys(pm)) {
			acls := pm[vrf]
			scope := fmt.Sprintf("/infra/tier-%ss/%s", acls[0].tier, vrf)
			var nsxRules []jsonMap
			ruleNum := 1
			for _, acl := range acls {
				hardware := strings.TrimSuffix(acl.name, "_in")
				direction := "IN"
				if hardware == "IN" {
					direction = "OUT"
				}
				// From gateway firewall documentation:
				// If there are multiple rules with the same sequence
				// number then their order is not deterministic. If a
				// specific order of rules is desired, then one has to
				// specify unique sequence numbers.
				//
				// Netspoc assumes that rules are checked in list order.
				// But we don't need to add a sequence number for each
				// rule. Only when the action of a rule changes, the
				// sequence must be preserved.
				//
				// Hence we use these sequence numers for rules
				// generated by Netspoc:
				// - 10 for prepended DROP rules
				// - 20 for plain ALLOW rules
				// - 30 for final DROP rule
				//
				// For rules from "managed = local":
				// - 10 for prepended DROP rules
				// - 20 for plain ALLOW rules
				// - 30 for DROP rule of local traffic
				// - 40 for final ALLOW rule
				//
				// For additional rules from raw file, intermediate
				// sequence numbers like 5, 15, 25, 35 should be used.
				seqNum := 20
				isDeny := acl.rules[0].deny
				if isDeny {
					if len(acl.rules) > 1 {
						seqNum = 10
					} else {
						seqNum = 30
					}
				}
				for _, rule := range acl.rules {
					if isDeny != rule.deny {
						seqNum += 10
						isDeny = rule.deny
					}
					rName := fmt.Sprintf("r%d", ruleNum)
					ipV46 := "IPV4"
					ruleNum++
					if rData.ipv6 {
						// Prevent name clash between IPv4 and IPv6 rules
						rName = "v6" + rName
						ipV46 = "IPV6"
					}
					nsxRule := jsonMap{
						"resource_type":      "Rule",
						"id":                 rName,
						"action":             getAction(rule),
						"source_groups":      getAddress(rule.src),
						"destination_groups": getAddress(rule.dst),
						"services":           single(getService(rule)),
						"ip_protocol":        ipV46,
						"scope":              single(scope),
						"direction":          direction,
						"sequence_number":    seqNum,
						"profiles":           single("ANY"),
					}
					addLog(rule, nsxRule, acl)
					nsxRules = append(nsxRules, nsxRule)
				}
			}
			policyName := "Netspoc-" + vrf
			result = append(result, jsonMap{
				"resource_type": "GatewayPolicy",
				"id":            policyName,
				"rules":         nsxRules,
			})
		}
		return result
	}
	getGroups := func() []jsonMap {
		var result []jsonMap
		for _, acl := range rData.acls {
			for _, g := range acl.objectGroups {
				var l []string
				for _, n := range g.elements {
					l = append(l, getAddress(n)...)
				}
				groupName := "Netspoc-" + g.name
				addresses := jsonMap{
					"id":            "id",
					"resource_type": "IPAddressExpression",
					"ip_addresses":  l,
				}
				result = append(result, jsonMap{
					"id":         groupName,
					"expression": []jsonMap{addresses},
				})
			}
		}
		return result
	}
	getServices := func() []jsonMap {
		var result []jsonMap
		for _, name := range slices.Sorted(maps.Keys(protoMap)) {
			pair := protoMap[name]
			p := pair.prt
			proto := p.protocol
			svcEntry := jsonMap{"id": "id"}
			switch proto {
			case "tcp", "udp":
				svcEntry["resource_type"] = "L4PortSetServiceEntry"
				svcEntry["l4_protocol"] = strings.ToUpper(proto)
				if len(p.name) > len(proto) {
					ports := p.name[len(proto)+1:]
					svcEntry["destination_ports"] = single(ports)
				} else {
					svcEntry["destination_ports"] = []string{}
				}
				if s := pair.srcRg; s != nil {
					ports := s.name[len(s.protocol)+1:]
					svcEntry["source_ports"] = single(ports)
				} else {
					// For simpler compare with config read from NSX device.
					svcEntry["source_ports"] = []string{}
				}
			case "icmp":
				svcEntry["resource_type"] = "ICMPTypeServiceEntry"
				var icmpProto string
				if rData.ipv6 {
					icmpProto = "ICMPv6"
				} else {
					icmpProto = "ICMPv4"
				}
				svcEntry["protocol"] = icmpProto

				if typ := p.icmpType; typ != -1 {
					svcEntry["icmp_type"] = typ
					if code := p.icmpCode; code != -1 {
						svcEntry["icmp_code"] = code
					}
				}
			default:
				svcEntry["resource_type"] = "IPProtocolServiceEntry"
				svcEntry["protocol_number"], _ = strconv.Atoi(proto)
			}
			result = append(result, jsonMap{
				"id":              name,
				"service_entries": []jsonMap{svcEntry},
			})
		}
		return result
	}

	fmt.Fprintln(fd)
	p := getPolicies(rData.acls)
	g := getGroups()
	s := getServices()
	result := jsonMap{
		"groups":   g,
		"services": s,
		"policies": p,
	}
	enc := json.NewEncoder(fd)
	enc.SetIndent("", " ")
	enc.SetEscapeHTML(false)
	enc.Encode(result)
	fmt.Fprintln(fd)
}

func printCombinedNSX(fd *os.File, config []string, rData *routerData) {
	// Print config and insert printed configuration at aclMarker.
	for _, line := range config {
		if strings.HasPrefix(line, aclMarker) {
			// Print rules.
			printNSXRules(fd, rData)
		} else {
			// Print unchanged config line.
			fmt.Fprintln(fd, line)
		}
	}
}
